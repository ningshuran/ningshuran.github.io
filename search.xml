<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android-CTS认证测试]]></title>
    <url>%2F2017%2F08%2F22%2FAndroid-CTS%E8%AE%A4%E8%AF%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Android-CTS认证测试一、什么是CTSGoogle GSM 认证测试组成 CTS 为 Compatibility Test Suite（兼容性测试） CTS的目的就是让各种Android（如手机）开发商能够开发出兼容性更好的Android设备。 GTS为 GMS Test Suite（GMS测试用例包） GTS的目的是让各种Android设备上的原生Google GSM 应用能稳定的运行和使用。 ctsVerifier 即ctsVerifier.apk(包含其配套测试资源)，补充CTS测试，安装到Android 设备上逐条手动测试，有些测试需要用到外设（如USB Microphone和Audio）配合测试。 二、获取CTS/GTS/ctsVerifier测试资源1、CTS官方下载地址 (翻墙网络环境)：http://source.android.com/compatibility/downloads.html 下载对应Android 7.0 版本下的最新arm架构的CTS测试包， 展讯9861平台使用x86架构的CTS测试包。 2、GTS客户需要和google签约，获取License，取得widevine专利代码，集成到Android版本，预置GMS包，用获取GTS测试包测试， 7.0 widevine，由Google 或者其第三方机构提供 ，平台不发布， 合入路径：/system/vendor/lib/mediadrm/libwvdrmengine.so 3、CtsVerifier官方下载地址 (翻墙网络环境)：http://source.android.com/compatibility/downloads.html 下载对应Android 7.0 版本下的最新arm架构的ctsVerifier测试包， 展讯9861平台使用x86架构的ctsVerifier测试包， CTS media文件获取路径地址和CTS/ctsVerifier一样，但是 7.0 需要选择 android-cts-media-1.2.zip 测试前确认需要测试的CTS包版本， CTS和CTS Verifier对应。 三、配置CTS环境测试包 CTS测试工具的压缩文件，前Android 7.0最新CTS测试包为 android-cts-7.0_r10-linux_x86-arm.zip GTS测试工具的压缩包最新为（GTS测试包不区分Android系统） android –gts-4.1 r2.zip 需要解压，在该文件路径下输入：unzip xxxxx.zip即可解压。 四、CTS测试前设备设置测试版本要求为user版本 语言设置为English(United States) 需要和软件工程师确认版本为user版本 开启“USB调试“ Settings &gt; Language &amp; input &gt; language，设为English(United States) 选择Android keyboard输入法 settings &gt; Language &amp; input &gt; Default &gt; Android keyboard，勾选 保持唤醒状态 状态栏下拉 &gt; USB debugging connected &gt; Developer options &gt; USB debugging，勾选 设置屏幕超时为最长时间30分钟 Settings &gt; Display &gt; Sleep &gt; 30 minutes，勾选 设置永不锁屏 Settings &gt; Security &gt; Screen lock &gt; none，勾选 连接可用wifi（翻墙的AP） 最好是支持IPV6的翻墙wifi 开启蓝牙 Settings &gt; Bluetooth ，打开 拷贝媒体文件 Ubuntu上运行android-cts-media-1.2文件copy_media.sh脚本或者手动将bbb_short、bbb_full到sd卡test文件中 SIM卡本机号码设置 需要将卡号写道对应的SIM卡上，并到设置中查看：设置-&gt;关于手机-&gt;状态消息， 开启Location Settings &gt; Location &gt; On（6.0以上版本每次执行前均会检查GPS是否开启，未开启则停止测试）]]></content>
      <categories>
        <category>Android CTS</category>
      </categories>
      <tags>
        <tag>Android CTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-OTA差分包升级失败]]></title>
    <url>%2F2017%2F08%2F10%2FAndroid-OTA%E5%B7%AE%E5%88%86%E5%8C%85%E5%8D%87%E7%BA%A7%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[Android-解决OTA差分包升级失败每次编译版本make之后都要执行make otapackage命令，make otapackage就是生成ota包的，一个完整包，一个中间包。每次编译完版本后都要保存这两个包，否则就不能做OTA升级。今天./build/tools/releasetools/ota_from_target_files –block -i -v old_target.zip new_target.zip update.zip生成的差分包发现不能升级。从之前编完版本保留下来的build.prop和今天保留的build.prop发现里面的recovery_id不一样，说明make之后没有再执行make otapackage，而发去出的版本正是这个没有make otapackage的版本，那完蛋了，这下怎么办了，用户买了手机今后不能升级了。 差分包大致是根据新老版本中间包去做差异对比的，./build/tools/releasetools/ota_from_target_files –block -i -v old_target.zip new_target.zip update.zip此命令如果不添加 –block 参数，意思是拿out/…/system目录下的…/app/，…/priv-app/来做对比，如果加了–block参数，则是用out/…/system.img做差异。 目前情况是,发出的版本是v1.0版本，然后在此版本上make之后没有make otapackage，保留的是make后的整包和差分包，相当于保留的包是v1.1的版本，而今天出的才是v1.1版本的。 解决方法121,用发出去的版本的system.img替换没有make otapackage的中间包的system.img2,用发出去的版本的out/.../system目录下的.../app/，.../priv-app/的APK替换没有make otapackage的中间包APK 但是目前添加–block很不稳定，很有可能不能生成差分包。那尝试替换APK的方法，首先根据差分包升级报错的APK用adb pull system/app/xxx.apk D:/out 发出版本的APK从手机pull出来， 一个一个替换没有make otapackage的中间包的APK。 然而中途发现，user版本有些文件是没有权限提取出来的！这可如何是好！ 就展讯平台来说，每个版本都打包一个.PAC包,此包里面包含各种.img的文件。 那可以尝试解包PAC,从中提取system.img，因为此包包含system各种APK等等文件。解包PAC可以用展讯刷机工具加载PAC包,在安装目录bin下可以找到加载的包,从中可以提取system.img 那问题来了system.img又如何解包呢？ ROM大师，玩机达人解包神器，加载system.img后点击配置文件，里面就是所有的system目下的东西,用对比工具对比system目录和中间包的system目录的差异，直接替换。（中间包为.zip格式文件，不要解压,用360压缩工具打开直接替换，因为解压中间包再重新打包生成不了差分包，不知道中间包的打包格式） 最后./build/tools/releasetools/ota_from_target_files -i -v old_target.zip new_target.zip update.zip 不要–block成功生成差分包。验证成功！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-姓名过长的联系人无法复制到SIM]]></title>
    <url>%2F2017%2F06%2F02%2FAndroid-%E5%A7%93%E5%90%8D%E8%BF%87%E9%95%BF%E7%9A%84%E8%81%94%E7%B3%BB%E4%BA%BA%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E5%88%B0SIM%2F</url>
    <content type="text"><![CDATA[Android-姓名过长的联系人无法复制到SIMSIM卡联系人姓名字段的长度是有限制的，这跟SIM卡的设据原理有关（根据SIM卡设计原理，能存储在SIM卡的单个联系人长度为28个字符，14个字符用于存储号码，另外14个字符用于存储联系人姓名），若为汉字，最多11个，若为英文字母，最多14个，是无法进行修改的。 http://blog.csdn.net/wds1181977/article/details/40620141 如果对名字字符串截取,是否考虑名字保存不完全的情况,从用户角度来看，也属于BUG，对名字截取个人觉得没有必要，人都是外号的，小明小红什么的，就算是英文也不会写全名，毕竟sim卡已经有限定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I get you]]></title>
    <url>%2F2017%2F05%2F22%2Fget%20%E2%88%9A%2F</url>
    <content type="text"><![CDATA[I get youhttps://www.zhihu.com/question/39501641 被不会撩妹的男人强撩是什么体验？ https://www.zhihu.com/question/39501641 为什么轻易得到的东西（或者人）就不会珍惜？ https://www.zhihu.com/question/20866485 接吻有哪些小技巧？ https://www.zhihu.com/question/28333998 太快确定关系的感情是不是也容易太快夭折？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Neko 我喜欢你]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[Neko 我喜欢你 那天我匆匆忙忙出门，大概快到9点的时候，我赶到了A栋一楼，好长队伍。 我第一次看见你，就是在队伍转弯处，迎面走过去，正好你也转过头来，也看着我。这瞬间，这感觉，是被电到了吗，心里砰砰跳，好漂亮，这女孩不错。 从那时候起，我喜欢上你了，之后连续几天都在电梯口看见你，然后开始关注你，知道你名字是因为你打开在我前面，我故意走慢一点的，哈哈，是不是心机boy，然后云通信知道了你的手机号码，想着试下你微信是不是这个号码，一搜果然是！想方设法想和你套近乎，无奈你我没工作交集，直接加你微信吧，你会不会对我印象不好，会不会太唐突了。然后各种途径了解你的信息，天天偷偷看你，关注你，我都感觉自己是不是太猥琐了，大概快有两月吧，太煎熬了，又不知道你单身不单身，有没有男朋友，不管了，先加微信看朋友圈。没想到，拒绝了！你拒绝了！心里瞬间一凉，跟针扎了一下，心疼！报上名字你才肯加我。果断赶紧翻朋友圈啊，我看到了个男的抱着你！瞬间世界都暗了，心灰意冷，好难受，好想哭。幸亏我点开了评论~ 至今你什么都是拒绝我，我想你有你故事，我知道你对我不了解，到现在也是简单聊了几天，别说感情，这么无趣的人，还天天烦你，厌恶也还说不定。哎~给次机会我约你可以吗,给次机会让我追你好吗，我才刚来，我理想的上班环境搬了，我师傅走了，最后我心仪的人马上要跳了T T 喜欢上一个人不容易，从所未有的感觉，真的，给次机会不咯⊙︿⊙]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 预置APK]]></title>
    <url>%2F2017%2F05%2F17%2FAndroid-%E9%A2%84%E7%BD%AEAPK%2F</url>
    <content type="text"><![CDATA[Android 预置APK一、预置APK的三种方式第一种：/system/app 预置在该目录下的APK，用户不能卸载 第二种：/data/app 应用是可以卸载 第三种：/system/preloadapp 应用用户可以卸载，但是恢复出厂设置时可以还原 二、如何预置无源码APK使得用户可以卸载1、将apk拷贝到vendor/sprd/partner/prebuilt_apps/下 2、在vendor/sprd/partner/prebuilt_apps/目录下添加mk文件，在mk文件中添加apk的定义，apk按照下面的例子添加（此处以Test.apk为例） include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := Test LOCAL_MODULE_CLASS := APPS LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)（最终apk所放的目录） LOCAL_SRC_FILES := Test.apk include $(BUILD_PREBUILT) 三、如何预置有源码APK使得用户可以卸载1、在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以 预制一个名为Test的APK为例 2、将 Test.apk 放到 packages/apps/Test 下面； 3、在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := Test LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := $(call all-java-files-under, src) LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) include $(BUILD_PACKAGE) include $(call all-makefiles-under,$(LOCAL_PATH)) 4、修改/vendor/sprd/open-source/common_packages.mk 将 Test 添加到 PRODUCT_PACKAGES 里面。 四、如何将APK 预置到system/priv-app里？加入priv-app方法:在Android.mk中增加 LOCAL_PRIVILEGED_MODULE := true 五、如何预置APK使得用户可以卸载？有两种方法： 方法一： 在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以 预制一个名为Test的APK为例 将 Test.apk 放到 packages/apps/Test 下面； 在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # Module name should match apk name to be installed LOCAL_MODULE := Test LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := $(LOCAL_MODULE).apk LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) include $(BUILD_PREBUILT) 这个比不能卸载的多了一句 LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) 方法二： 将需要预置的 apk 拷贝到： vendor/mediatek/${Project}/artifacts/out/target/product/${Project}/data/app/ 重新 build 整个工程 如果没有相应目录则需手动创建。 六、如何使得用户在将预置的 APK 卸载后，恢复出厂设置时能恢复？为了让用户在将预置的 APK 卸载后，恢复出厂设置时能恢复， 做法是： 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/system目录下新建一个名为appbackup的文件夹，将该应用的apk文件copy到appbackup文件夹下 在mediatek/config/project_name/ProjectConfig.mk文件中添加定义：MTK_SPECIAL_FACTORY_RESET=yes 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/data/app下创建一个.restore_list，并且在其中添加语句： /system/appbackup/xxx.apk（注意，.restore_list中的每一行都要以&quot;/system” 开头） 当卸载了data/app下的apk后，再恢复出厂设置，系统会从 .restore_list 中读取apk的名字，然后从 appbackup 文件中把apk重新拷贝到data/app下，从而恢复data/app下已经卸载了的apk。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Camera SnxxDrogxxCamera预览大小和照片大小]]></title>
    <url>%2F2017%2F04%2F10%2FAndroid-Camera-SnxxDrogxxCamera%E9%A2%84%E8%A7%88%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%85%A7%E7%89%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[Android Camera SnxxDrogxxCamera预览大小和照片大小预览大小和照片大小是在CameraSettings， 初始化相机预览大小 1234567891011121314151617181920212223242526272829303132333435 // 初始化相机预览大小public static void initialCameraPreviewSize(Context context, Parameters parameters) &#123; // When launching the camera app first time, we will set the picture // size to the first one in the list defined in &quot;arrays.xml&quot; and is also // supported by the driver. // 当第一次启动相机应用程序时，我们将将预览图片大小设置为“xml”中定义的列表中的第一个，并由驱动程序支持。 String previewSize = ComboPreferences.get(context).getString( CameraSettings.KEY_PREVIEW_SIZE, null); // 第一次设预览大小为&quot;1920x1080&quot; if (previewSize == null) &#123; previewSize = &quot;1920x1080&quot;; SharedPreferences.Editor editor = ComboPreferences.get(context) .edit(); editor.putString(KEY_PREVIEW_SIZE, previewSize); editor.apply(); &#125; // 获得可支持的预览大小 List&lt;Size&gt; supported = parameters.getSupportedPreviewSizes(); if (supported == null) return; // 获取可支持列表 // for (String candidate : context.getResources().getStringArray( // R.array.pref_camera_previewsize_entryvalues)) &#123; // 匹配支持列表，设置为列表第一个 if (setCameraPreviewSize(previewSize, supported, parameters)) &#123; // SharedPreferences.Editor editor = ComboPreferences // .get(context).edit(); // editor.putString(KEY_PREVIEW_SIZE, candidate); // editor.apply(); return; &#125; // &#125; Log.e(TAG, &quot;No supported preview size found&quot;);&#125; 这里强制设置第一次进入到相机的预览界面为1920x1080，但如果设备不支持的话是按array定义的第一个，其中List supported = parameters.getSupportedPreviewSizes();可以获得设备支持的预览大小，而context.getResources().getStringArray(R.array.pref_camera_previewsize_entryvalues) 可以获得array定义的预览大小列表，这是有区别的。 初始化拍照后图片的大小 123456789101112131415161718192021// 初始化拍照后图片的大小public static void initialCameraPictureSize(Context context, Parameters parameters) &#123; // When launching the camera app first time, we will set the picture // size to the first one in the list defined in &quot;arrays.xml&quot; and is also // supported by the driver. // 当第一次启动相机应用程序时，我们将将图片大小设置为“xml”中定义的列表中的第一个，并由驱动程序支持 List&lt;Size&gt; supported = parameters.getSupportedPictureSizes(); for (String candidate : context.getResources().getStringArray( R.array.pref_camera_picturesize_entryvalues)) &#123; if (setCameraPictureSize(candidate, supported, parameters)) &#123; SharedPreferences.Editor editor = ComboPreferences.get(context) .edit(); editor.putString(KEY_PICTURE_SIZE, candidate); editor.apply(); return; &#125; &#125; Log.e(TAG, &quot;No supported picture size found&quot;);&#125; List supported = parameters.getSupportedPictureSizes();先获取支持的图片大小，再遍历array列表，再通过setCameraPictureSize(candidate, supported, parameters)匹配设备可支持的，第一次匹配则return,达到设置array列表第一个的效果。 判断是否匹配支持列表，并且设置相机预览大小 12345678910111213141516171819202122// 判断是否匹配支持列表，并且设置相机预览大小public static boolean setCameraPreviewSize(String candidate, List&lt;Size&gt; supported, Parameters parameters) &#123; // 传入备选大小 ，获得x位置索引 int index = candidate.indexOf(&apos;x&apos;); if (index == NOT_FOUND) return false; int width = Integer.parseInt(candidate.substring(0, index)); int height = Integer.parseInt(candidate.substring(index + 1)); // 匹配支持列表 for (Size size : supported) &#123; if (size.width == width &amp;&amp; size.height == height) &#123; //匹配则设置预览大小 parameters.setPreviewSize(width, height); return true; &#125; &#125; return false;&#125; 这个返回的是一个boolean值，这样写有一个好处，一个可以用来做判断是否可以匹配列表，再一个可以设置相机预览大小。candidate是传入的一个字符串的”1920x1080”这样的字符串。 判断是否匹配支持列表，并且设置相机预览大小 123456789101112131415//判断是否匹配支持列表，并且设置相机预览大小public static boolean setCameraPictureSize(String candidate, List&lt;Size&gt; supported, Parameters parameters) &#123; int index = candidate.indexOf(&apos;x&apos;); if (index == NOT_FOUND) return false; int width = Integer.parseInt(candidate.substring(0, index)); int height = Integer.parseInt(candidate.substring(index + 1)); for (Size size : supported) &#123; if (size.width == width &amp;&amp; size.height == height) &#123; parameters.setPictureSize(width, height); return true; &#125; &#125; return false;]]></content>
      <categories>
        <category>Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Launcher3预置文件夹、快捷方式、桌面小部件]]></title>
    <url>%2F2017%2F04%2F02%2FAndroid-Launcher3%E9%A2%84%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%81%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E3%80%81%E6%A1%8C%E9%9D%A2%E5%B0%8F%E9%83%A8%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android Launcher3预置文件夹、快捷方式、桌面小部件一预置文件夹、快捷方式、网页桌面快捷方式123456789101112131415161718192021222324&lt;folder launcher:screen=&quot;0&quot; \\第几个页面，0是最中间的页面 launcher:x=&quot;0&quot; \\放在横向的哪个位置 launcher:y=&quot;4&quot; \\放在竖向的哪个位置 launcher:title=&quot;@string/built_in_folder_toolkit&quot;&gt; /*文件夹里面的应用图标*/ &lt;favorite launcher:packageName=&quot;com.android.calculator2&quot; //包名 launcher:className=&quot;com.android.calculator2.Calculator&quot;//类名 就是显示的Activity/&gt; &lt;favorite launcher:packageName=&quot;com.android.soundrecorder&quot; launcher:className=&quot;com.android.soundrecorder.SoundRecorder&quot; /&gt; &lt;favorite launcher:packageName=&quot;com.android.deskclock&quot; launcher:className=&quot;com.android.deskclock.DeskClock&quot; /&gt; /*网页快捷方式*/ &lt;shortcut launcher:uri=&quot;http://www.baidu.com&quot; launcher:icon=&quot;@drawable/ic_launcher_baidu&quot; //要显示的图标 launcher:title=&quot;@string/baidu_title&quot; //要显示的名字 launcher:screen=&quot;&quot; launcher:x=&quot;&quot; launcher:y=&quot;&quot; /&gt; &lt;/folder&gt; 二预置桌面小部件12345678&lt;appwidget launcher:packageName=&quot;com.android.settings&quot;launcher:className=&quot;com.android.settings.widget.SettingsAppWidgetProvider&quot; launcher:screen=&quot;3&quot; launcher:x=&quot;0&quot; launcher:y=&quot;0&quot; launcher:spanX=&quot;4&quot; //在屏幕上x方向所占的格子数 launcher:spanY=&quot;1&quot; //在屏幕上y方向所占格子数 /&gt;]]></content>
      <categories>
        <category>Android Launcher3</category>
      </categories>
      <tags>
        <tag>Android Launcher3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N 动态壁纸列表为空？]]></title>
    <url>%2F2017%2F03%2F27%2FAndorid-AnroidN%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8%E5%88%97%E8%A1%A8%E4%B8%BA%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[Android N 动态壁纸列表为空？原因分析： google 在7.0上去掉了动态壁纸，但保留了动态壁纸的框架。 google移除该功能可能是考虑到动态壁纸功能对手机的性能功耗等影响。 解决方法： 如果没有对壁纸的特殊需求，建议保持原生设计。 如果需要添加动态壁纸，请预置相应动态壁纸app即可。 例如，可以编译Android 6.0版本的动态壁纸app： packages/wallpapers/Galaxy4 packages/wallpapers/HoloSpiral packages/wallpapers/MagicSmoke … 编译之后预置到版本中即可(与预置其他第三方apk一样)]]></content>
      <categories>
        <category>Android Launcher3</category>
      </categories>
      <tags>
        <tag>Android Launcher3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 长按Home键没有弹出最近任务页面]]></title>
    <url>%2F2017%2F03%2F24%2FAndroid-%E9%95%BF%E6%8C%89Home%E9%94%AE%E6%B2%A1%E6%9C%89%E5%BC%B9%E5%87%BA%E6%9C%80%E8%BF%91%E4%BB%BB%E5%8A%A1%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Android 长按Home键没有弹出最近任务页面5.1上默认打开最近任务的按键键值是KEYCODE_APP_SWITCH，可以采取以下两种方案 1.增加对应KEYCODE_APP_SWITCH键值的按键 2.修改frameworks/base/core/res/res/values/config.xml中 &lt;integer name=&quot;config_longPressOnHomeBehavior&quot;&gt;0&lt;/integer&gt; 0的值至1 修改此项有可能会引起CTS不过。]]></content>
      <categories>
        <category>Android Framework</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPM]]></title>
    <url>%2F2017%2F03%2F22%2FSPM%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SPM工作流程一 软件项目前期1无手机硬件设备1.1软件的立项会议（立项中包含schedule，项目配置信息，项目干系人，质量标准，风险的评估等）1.2获取平台数据 （开发工具，接口文档等）1.3安排基线负责人编译基线 并保证编译正确。1.4所有的软件研发人员熟悉基线代码。1.5获取三方接口信息；1.6确认客户接口信息；1.7确认认证相关需求。2有手机硬件设备2.1 基线稳定基线原生bug 修复 稳定基线。 2.2 项目分支建立流程2.2.1 根据软件需求来评估分支的建立方案。Case 1 理论要求所有的软件分支 是要从主基线上拉分支 Case 2 如果客户要求在原有项目的基础上 再次更新版本那么就从原有项目上 拉分支 Case 3 如果客户要求在原有项目的基础上 再次更新版本但是由于某些需求的原因例如volte功能 而原有的项目分支无法实现。如果出现这样的情况 请根据实际的项目情况 来评估分支怎么拉合适。 2.2.2 根据软件完成的时间节点评估分支的建立方案只有一个原则 根据实际的研发时间和项目的时间来评估软件分支建立方案。 2.3 需求评估流程2.3.1 拿到客户的需求文档后 请安排各课长评估具体完成的时间点2.3.2 对于简单的需求 最小的时间单位为0.5天。2.3.3 对于复杂的需求 研发的时间为3~5 工作日2.3.4 对于评估时间大于5个工作日的需求 请协调相关工程师具体研究时间节点 并说明实现的难度和困难点在那里 即风险评估。2.3.5 对于无法实现的需求 一定要给出具体的说明来阐述这个需求为什么无法完成。2.3.6 所有的需求评估完成后 必须让测试部 提交对应的bug来跟踪。2.3.7需求归档备份。2.3.8 具体参考需求评估文档。2.4 对于TP LCD Camera 的调试安排2.4.1 和项目经理协调 TP LCD Camera 资源 每一个必须要2块以上 防止器件损坏 导致无效的工作。2.4.2 安排驱动部调试 并尽量协调资源来满足工程师的要求。2.4.3 每天更新器件调试进展， block项及时发出并通知给项目经理。2.5 对于MBN QCN 的调试安排（modem调试）2.5.1 和项目经理 协调资源 安排射频工程师和modem组联调 完成需求要求的频段。2.5.2 需要送平台商安排调试验证的 ，需要协调软件 硬件 射频资源来准备样机 安排实验室调试。2.6 根据评估的结果 输出软件版本计划。2.7 安排IT 建立对应项目的BUG库2.8 协调项目经理 给出测试部的接口人。2.9 提醒项目经理 安排工具组输出对应的BT FT 工具。二 软件项目中期1需求沟通1.1需求不明确对于不明确的需求 务必让工程师具体提出不明确的点 以邮件的方式通知SPM, SPM 负责和客户的需求经理或者是接口人来确认具体的需求。需求明确后务必请接口人更新需求文档 或者SPM 要备份沟通的结果，并在相应的bug中添加comment 说明沟通的结果。 1.2需求明确1.2.1可以修改的安排工程师给出具体的完成时间点并跟踪完成情况。 1.2.2不可以修改的（理论上都可以完成 关键在于研发的时间）请工程师给出具体的风险评估文档。或者邮件说明完成的困难点 风险点。SPM 负责和需求接口人来沟通。如果无法说服客户 就延长研发的时间 让工程师有更多的时间来完成此需求，如果需求的实现对项目计划有影响需要和项目经理进行确认。 2需求类bug跟踪每天定时check bug 修改情况，对于关心的问题必要时通过邮件跟踪。 3版本号控制原则3.1 版本号命名原则：Case 1 hiapd 内部版本号命名 需要有项目组 开会讨论后决定 目前没有相关的命名文档 Case 2 客户内部版本号 需要和客户沟通确认 必须邮件沟通确认 Case 3 外部版本号 需要和客户沟通确认 必须邮件沟通确认 3.2 内部版本号递增原则：Case 1 客户认可或者归档的B01版本后 再次释放版本需要+1（B02） Case 2 客户送测后 即送国外运行商（TA 版本） 或者是国内的送测后 再次释放版本需要+1 （比如 送测版本是B11 但是后续TA 反馈问题 我们修改后再次送测就需+1 即B12版本） Case 3 关于内部版本号的变更 有的地区在送测期间 可以随时更换版本 对于这样的情况 必须在版本释放前需要和客户邮件确认是否需要修改版本号。 3.3 外部版本号递增原则：Case 1 在没有释放量产版本前 保持不变（客户特殊要求除外） Case 2 国内CTA 版本 和国外的TA 版本 理论上外部版本号不变 但是释放版本时请和客户再次确认。 Case 3 后续通过FOTA 升级的版本 需要+1 （和客户邮件确认） Case 4 MR版本（售后版本）必须+1. 3.4 备注：版本号尽量控制在10个版本之内。 4编译和释放版本4.1 编译版本：4.1.1 根据要求输出编译脚本 并上传SVN4.1.2 在10.10.1.6 建立存放版本的文件夹 说明：目前脚本中不能自动新建文件夹 必须手动在.6服务器上创建文件夹。4.1.3 软件开始研发后 如果每日比较多 每天晚上需要编译版本即daily_build 如果每日修改比较少 可以 2~3天编译版本 SPM 根据实际情况自行决定。4.2 释放版本：4.2.1 临时版本释放临时版本的释放 多数情况下是为了解决某一个或者是多个问题 响应客户的要求释放的，这样的版本可以不经过测试部的测试。就可以释放给客户，但是需要SPM 或者测试同事简单的验证而且必须保证可以正常开机。并务必在邮件中明确说明这个是临时的版本 测试部没有系统测试的字样来告知客户。 临时的版本升级要了解客户手里的机器是什么状态的机器（器件是否有差异，版本信息）确认用户可以正常升级。 4.2.2 正式版本释放Case 1 非生产版本 对于非生产版本 必须经过软件测试部的测试即提交软件测试流程 并根据测试反馈的结果 来评估是否可以释放给客户。 Case 2 试产版本 是指要在产线上用于试产的版本 试产前提醒项目经理组织每次试产前做change list 评审（在试产回来每次验证中有可能需要软件配合修改的地方 这类版本必须经过软件测试部，硬件测试部，工作组的测试 并提交相应的测试流程，测试完成后评估是否可以用于生产 如果可以并上传DCC 系统下发工厂。 Case 3 量产版本 是在客户接受软件可以用于生产 量产前 请和项目经理确认是否有物料的变更 如果存在物料变更 需要软件调整并压力测试。还有需要明确量产软件的烧写方式。 这类软件必须 保证 CTS GTS 测试通过 （国内外通用）必须经过软件测试部，硬件测试部，工作组的测试 并提交相应的测试流程，测试完成后评估是否可以用于生产，如果可以并上传DCC系统下发工厂。 5安排测试部测试5.1 需求测试Case 1 在正式的B01版本发布前，即每天编译的版本进行测试。 Case 2 正式的B01版本 验证 Case 3 如果需要在B02 版本也请安排测试 5.2 bug 回归正式运行OA 流程提交的测试版本均需要安排此项测试。 5.3 CTS GTS 测试Case 1 在提交客户版本前 必须安排测试一次 即摸底的测试 Case 2 正式外发给客户的版本 必须安排测试。 Case 3 基线有重大升级后安排测试 Case 4 google 要求调整测试包 即CTS GTS 测试脚本变更 必须安排测试。 5.4 monkey 测试：Case 1 正式B01 安排测试。 Case 2 软件中集成比较多的三方apk 后请安排测试。 Case 3 版本有重大修改 比如基线调整 安排测试。 Case 4 送测的版本（TA版本） 请安排测试 5.5 FOTA 测试：正式外发的版本 均要求测试。 5.6 系统测试（系统全用例）正式外发的版本 均要求测试。 5.7 续航测试Case 1 量产前的软件版本 必须安排一次测试 Case 2 软件基线调整 安排测试 Case 3 添加大量三方apk 后 请安排测试。 5.8 待机电流测试正式的外发版本必须安排测试 5.9 信令连接测试正式的外发版本必须安排测试 5.10 射频测试量产前的版本 必须安排一次测试。 5.11 工具组测试正式的外发版本必须安排测试 5.12 场测场测前需要软件项目经理将启动场测的邮件发给项目相关成员，测试工程师将抓log的方法发出，让研发工程师进行确认。 6 UE 版本如果有UE 版本需求 请安排释放UE 版本 UE 释放要求 Case 1 基线基本稳定 没有重点的问题存在 Case 2 UE需求明确 7 CTA 版本如果有CTA版本需求 请安排释放CTA版本 7.1 CTA 版本需求合入已知CTA问题，解决前期个别问题 7.2 CTA 准备工作Case 1 测试用例确认 Case 2 确认资料 准备样机和配件 8外发客户B01版本(首个版本)8.1 根据软件版本计划 在计划时间点提交客户B01版本8.2 在提交B01 版本时 必须保证所有的需求修改完成 如果还存在需求未完成的 请SPM 和客户沟通来确认是否B01版本.8.3 必须安排相关的测试 ，并取得测试报告后 有项目组来评估是否可以释放给客户。9处理客户反馈的问题9.1 国内反馈9.1.1 客户测试team 反馈：Case 1 安排hiapd测试部 同步客户反馈问题提交到我们BUG库 Case 2 跟踪反馈问题 对bug 描述不明确的请协助工程师沟通。 9.1.2 客户邮件反馈：接到反馈邮件后 请安排测试部的同事复现 如果可以复现请安排测试部提交bug。如果无法复现的问题 请spm和客户沟通确认问题。 9.2 国外反馈国外的反馈 一般都是在国内无法测试的问题。SPM务必整理备份。问题主要集 中在 协议组和modem组 9.2.1 协议组问题：务必请客户提供adb log ，qxdm log，视频或者是截图并提供对比机的测 试情况 对于短彩信问题请客户提供短信数据库文件，对比机apn 参数。 9.2.2 modem组问题：务必请客户提供adb log ，qxdm log，视频或者是截图 和qcn文件。对比 机的测试情况。 10外发TA 版本：10.1 时间点：取决于软件版本计划。如果客户不认可版本计划，必须和项目经理沟通后 再和 客户讨论并邮件确认时间点。 10.2 处理TA 反馈问题：10.2.1 问题反馈：请客户提交相关的资源 即log 视频等 安排测试部复现 并提交bug 安排工程师分析。 10.2.2 新增需求：参考需求评估流程来确认时间点 并和项目经理确认是否需要完成。Spm 没有权利答复客户。 三 软件项目后期1了解客户测试流程1.1中兴客户：通过的标准应该是5A 40B，除此之外，A类Bug,如果分值高的话，是一票否决的，出现这种分值高的bug,要格外注意，尽快处理。模拟用户的标准应该是B类不超过12%，非问题bug及不重要的bug,尽早沟通关闭或降级。 1.2联想客户：1.3中国移动：2 bug 评审机制：在项目量产前 需要项目组相关人员和研发课长 来评估所有bug 的风险，确定修改的方案。修改的时间点等信息。对于不做修改的问题统一降级为4级。 3外发量产版本：3.1前提条件：Case 1 客户必须TA 或者是明确邮件确认软件可以量产。 Case 2 现有存在的bug 符合客户的量产标准。 Case 3 工程模式中没有严重的问题。 Case 4 CTS GTS 测试没有fail项。 3.2测试安排：务必启动量产软件外发流程。 3.3主要事项：Case 1 注意客户拿到量产软件的时间点。 Case 2 CTS GTS 测试。 Case 3 工具组测试。 Case 4 FOTA 版本必须生成和验证。 4书写项目总结项目量产后 请务必输出项目总结。 四 软件项目维护是指项目已经量产，主要是由于售后问题客户要求我们更新软件。对于这些软件我们称MR 版本。 MR 版本生成要做到最小的修改。即将风险降到最低。 MR 版本生成原则 1.1只安排修改客户反馈的问题。1.2对于一些必要的功能 进行升级例如AFW 功能和 CTS GTS 的问题。1.3FOTA 版本必须验证 （例如 量产软件是B12，售后反馈问题我们出B13 那么FOTA 必须验证 B12 B13,B13B14 2个版本）1.4MR 版本的测试也要符合量产软件测试标准。五 沟通的注意事项1一定要第一时间响应客户提出的各种问题。2对于一些问题的沟通 如果有工程师介入 尽量发给相关的人员不要全部回复。3对于客户要求确认时间点的邮件 务必需要和项目经理沟通后再回复。4对于一些需求功能的确认 一定要和相关的工程师沟通后再回复。六 软件需求评估项目各阶段客户需求评估策略 序号 项目阶段 客户需求评估策略 备注 1 立项前 尽量满足客户需求，根据实际评估情况给出风险预估，资源需求，进度安排。对于不能实现或部分实现的需求要提交客户确认。 SPM要全面收集客户需求，避免遗漏 2 立项EVT 满足客户合理需求，根据实际评估情况给出风险预估，资源需求，进度安排。 SPM作需求变更记录 3 EVT DVT 满足客户合理的小型需求，对于工作量和难度较大的需求，需要在进度评估和风险评估的基础上与客户沟通。 SPM作需求变更记录 4 DVT PVT 通常不再接收新的客户需求。特殊情况需要客户对进度做出让步，风险共担。 SPM作需求变更记录 5 PVT MP 不再接收新的客户需求。客户强烈要求的，给出风险评估和进度评估，在此基础上要求客户风险共担。 SPM作需求变更记录 6 MP 不再接收新的客户需求。客户如有要求，根据工作量评估进度，并且要提报PM成本增加。新需求不影响原有量产进度情况下作为后续维护升级需求开发。 SPM作需求变更记录 6.3运营商软件需求评估流程 6.3.1运营商的需求由公司产品认证部及时更新到SPM 6.3.2 SPM根据运营商需求的时效和产品类别，确认本项目是否需要导入评估 6.3.3对于需要导入的运营商需求直接启动开发流程 6.4公司内软件需求评估流程 6.4.1公司内的软件需求是由公司内其他部门提出，给到SPM 6.4.2SPM启动软件需求评估流程 6.4.3SPM根据实际评估结果决定是否在项目中实施 6.4.4若SPM判定不实施该需求，需与提出需求部门沟通说明原因 6.4.5如有分歧意见，双方给出各自理由，由PM决断。]]></content>
      <categories>
        <category>SPM</category>
      </categories>
      <tags>
        <tag>SPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 修改默认亮度太暗]]></title>
    <url>%2F2017%2F03%2F20%2FAndroid-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%BA%AE%E5%BA%A6%E5%A4%AA%E6%9A%97%2F</url>
    <content type="text"><![CDATA[Android 修改默认亮度太暗修改屏幕默认亮度frameworks\base\packages\SettingsProvider\res\values\defaults.xml &lt;integer name=&quot;def_screen_brightness&quot;&gt;102&lt;/integer&gt; 这个值的取值范围为0~255，按照实际需求修改”def_screen_brightness”的值。 很多项目会在/device/对应平台/对应工程/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml overlay 这个xml文件，所以会导致只修改frameworks中的值并不会起作用。因此，需要优先检查是否存在overlay的情况。 修改最小,最大亮度值，以及开机启动的默认亮度值最小值，不得小于0： &lt;integer name=&quot;config_screenBrightnessSettingMinimum&quot;&gt;30&lt;/integer&gt; 最大值，建议不大于255： &lt;integer name=&quot;config_screenBrightnessSettingMaximum&quot;&gt;255&lt;/integer&gt; 默认值，介于最大值及最小值中间： &lt;integer name=&quot;config_screenBrightnessSettingDefault&quot;&gt;100&lt;/integer&gt;]]></content>
      <categories>
        <category>Android Framework</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb命令]]></title>
    <url>%2F2017%2F02%2F26%2Fadb%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[adb命令Android adb你真的会用吗?http://www.jianshu.com/p/5980c8c282ef adb基本命令https://my.oschina.net/atearsan/blog/342954 Awesome Adb——一份超全超详细的 ADB 用法大全https://github.com/mzlogin/awesome-adb ADB用法大全http://www.tuicool.com/articles/2MFJri6]]></content>
      <categories>
        <category>adb命令</category>
      </categories>
      <tags>
        <tag>adb命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN命令]]></title>
    <url>%2F2017%2F02%2F25%2FSVN%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[SVN命令1、 将文件checkout到本地目录 svn checkout path（path是服务器上的目录） 例如：svn checkout svn: // 192.168 . 1.1 / pro / domain 简写：svn co 2、 往版本库中添加新的文件 svn add file 例如：svn add test.php(添加test.php) svn add * .php(添加当前目录下所有的php文件) 3、 将改动的文件提交到版本库 svn commit -m &quot; LogMessage &quot; [ -N ] [ --no-unlock ] PATH (如果选择了保持锁，就使用--no-unlock开关) 例如：svn commit -m &quot; add test file for my test &quot; test.php 简写：svn ci 4、 加锁/解锁 svn lock -m &quot; LockMessage &quot; [ --force ] PATH 例如：svn lock -m &quot; lock test file &quot; test.php svn unlock PATH 5、 更新到某个版本 svn update -r m path 例如： svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved ，最后再提交commit) 简写：svn up 6、 查看文件或者目录状态 1 ）svn status path （目录下的文件和子目录的状态，正常状态不显示） 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 2 ）svn status -v path (显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 简写：svn st 7、 删除文件 svn delete path -m &quot; delete test fle &quot; 例如：svn delete svn:// 192.168.1.1 /pro/domain/test.php -m &quot; delete test file &quot; 或者直接svn delete test.php 然后再svn ci -m &apos;delete test file‘，推荐使用这种 简写：svn (del, remove, rm) 8、 查看日志 svn log path 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、 查看文件详细信息 svn info path 例如：svn info test.php 10、 比较差异 svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php 简写：svn di 11、 将两个版本之间的差异合并到当前文件 svn merge -r m:n path 例如：svn merge -r 200 : 205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、 SVN 帮助 svn help svn help ci 以上是常用命令，下面写几个不经常用的13、 版本库下的文件和目录列表 svn list path 显示path目录下的所有属于版本库的文件和目录 简写：svn ls 14、 创建纳入版本控制下的新目录 svn mkdir : 创建纳入版本控制下的新目录。 用法: 1、mkdir PATH... 2、mkdir URL... 创建版本控制的目录。 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增 调度，以待下一次的提交。 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。 在这两个情况下，所有的中间目录都必须事先存在。 15、 恢复本地修改 svn revert : 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 用法: revert PATH... 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复 被删除的目录 16、 代码库URL变 svn switch (sw): 更新工作副本至不同的URL。 用法: 1、switch URL [PATH] 2、switch --relocate FROM TO [PATH...] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用 这个命令更新工作副本与仓库的对应关系。 17、 解决冲突 svn resolved: 移除工作副本的目录或文件的“冲突”状态。 用法: resolved PATH... 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的 相关文件，然后让 PATH 可以再次提交。 18、 输出指定文件或URL的内容。 cat 目标[@版本]...如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)]]></content>
      <categories>
        <category>SVN命令</category>
      </categories>
      <tags>
        <tag>SVN命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser辅助功能甩动手势前进后退功能研究]]></title>
    <url>%2F2016%2F10%2F15%2FAndroid-Browser%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E7%94%A9%E5%8A%A8%E6%89%8B%E5%8A%BF%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Android Browser 甩动手势Android Browser在设置-辅助功能里面有个甩动手势功能，有时候甩动却发现没有效果。 实现这个甩动手势的有一个类ShakeDetector，它是实现了SensorEventListener这个类。 覆盖重写了onSensorChanged（SensorEvent event）这个方法，研究这个类和这个方法，可以发现，甩动跟方向和加速度，甩动时间有关。 而出现甩动没有效果，可能还跟重力传感器有关，有些重力传感器本身就是不支持横屏的。 我研究到后来发现一个初始参数 final float SHAKE_THRESHOLD = 6.0f; 当把它调小后，甩动效果更灵敏了。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email登陆邮箱后，清除邮箱数据后，再进入邮箱，邮箱会闪退]]></title>
    <url>%2F2016%2F05%2F06%2FAndroid-Email%E7%99%BB%E9%99%86%E9%82%AE%E7%AE%B1%E5%90%8E%EF%BC%8C%E6%B8%85%E9%99%A4%E9%82%AE%E7%AE%B1%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E5%86%8D%E8%BF%9B%E5%85%A5%E9%82%AE%E7%AE%B1%EF%BC%8C%E9%82%AE%E7%AE%B1%E4%BC%9A%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[Android Email登陆邮箱后，清除邮箱数据后，再进入邮箱，邮箱会闪退After viewing the video and analyzing the logs provided for the scenario, it looks like the reported behavior is not an issue. It is the expected flow. Email app getting notified that App data and settings were cleared, which will further trigger to remove all Email accounts in the account manager and Account Manager notifying Email application back that the account has been deleted : - All these actions occur asynchronously. Hence the timing of the broadCast events plays a vital role in deciding the screen behavior when Application is relaunched. Please look into the below sequence so that you can understand the behavior better. At this point, Email account was set initially and Mailbox was displayed to the user. Now, package cleared from settings : 在观看视频并分析提供给场景的日志之后，它看起来像报告的行为不是一个问题。这是预期的流动。电子邮件应用程序收到通知，应用程序数据和设置被清除，这将进一步触发删除所有电子邮件帐户在帐户管理器和帐户管理器通知电子邮件应用程序返回帐户已被删除：-所有这些行动发生异步。因此，广播事件的时间起着至关重要的作用，在决定行为时，应用程序重新启动屏幕。请看下面的顺序，以便你能更好地理解行为。此时，电子邮件帐户已初步设置，并将邮箱显示给用户。现在，包从设置中清除： 06-22 14:15:26.626364 2108 2119 V ActivityManager: Broadcast: Intent { act=com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{48a6efa 8944:com.android.settings/1000} Clearing the package also causes Email to stop. Now, Email App is launched Please look into the below sequence so that you can understand the behavior better. At this point, Email account was set initially and Mailbox was displayed to the user. Now, package cleared from settings : 清理包裹也会导致电子邮件停止。现在，电子邮件应用程序启动请看下面的顺序，以便你能更好地理解行为。此时，电子邮件帐户已初步设置，并将邮箱显示给用户。现在，包从设置中清除： 06-22 14:15:26.626364 2108 2119 V ActivityManager: Broadcast: Intent { act=com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{48a6efa 8944:com.android.settings/1000} Clearing the package also causes Email to stop. Now, Email App is launched again by tapping the Launcher. But at this point we still did not receive settings package cleared broadcast intent that was previously sent:06-22 14:15:25.970301 2108 2907 I am_kill : [0,31972,com.android.email,1,stop com.android.email]………………………………………..06-22 14:15:28.821498 2108 2473 I am_create_task: [0,98]06-22 14:15:28.821687 2108 2473 I am_create_activity: [0,202452453,98,com.android.email/.activity.Welcome,android.intent.action.MAIN,NULL,NULL,270532608] BroadCast intent received and Accounts deletion in AccountManager is initiatedby Email App: 广播意图收到并开始删除AccountManager帐户通过电子邮件应用： 06-22 14:15:30.505155 720 881 D Email : onHandleIntent start:action = broadcast_receiver06-22 14:15:30.505900 720 881 D Email : onHandleIntent:broadcastAction = com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED06-22 14:15:30.511159 720 881 D Email : !!!onSettingsPackageClearData: send broadcastto laucher : unreadCount = 006-22 14:15:30.511644 720 881 D SettingsInterface: putStringForUser, name = com_android_email_mtk_unread, value = 0, for user : 006-22 14:15:30.943661 720 881 D Email : onHandleIntent end = broadcast_receiver Account is deleted in AccountManager and Email Application gets notified:06-22 14:15:38.968635 720 720 D Email : onReceive:action = android.accounts.LOGIN_ACCOUNTS_CHANGED 电子邮件核对账户接收广播，关闭电子邮件应用程序的学习之后，一个帐户已被删除： Email reconciles Accounts on receiving the broadCast, which shuts down Email App after learning that an account has been deleted:06-22 14:15:40.742920 720 1207 D Email : Setting compose activity to disabled06-22 14:15:40.743112 720 1207 I Email : Restarting because account deleted This scenario cannot be an always scenario, if the Email application is launched after a delay when package data is cleared.To check this please enter the Email application after a delay, say after a minute. Here acount login-screen will be visible instead of Mailbox and the Email application will not exit. This particular behavior, where Email application and services are killed when we learn that an account is deleted, is a safe way to avoid many other issues, as there could be any background action going on related to the deleted account, which may cause some serious problems. Although not as clean as it could be, killing the application is the best and the simplest thing we could do to avoid further issues with the deleted account. 如果在包数据被清除后延迟启动电子邮件应用程序，则此方案不能始终为场景。要检查这一点，请输入电子邮件应用程序后的延迟，说一分钟后。在这里，我们将看到登录屏幕而不是邮箱和邮件应用程序将不会退出。这种特殊的行为，在电子邮件应用程序和服务被杀害时，我们了解到一个帐户被删除，是一种安全的方式，以避免许多其他问题，因为可能有任何背景行动进行有关删除帐户，这可能会导致一些严重的问题。虽然没有尽可能干净，杀死应用程序是最好的，我们可以做的最简单的事情，以避免进一步的问题，已删除的帐户。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android HTMLViewer 打开.txt显示乱码]]></title>
    <url>%2F2016%2F05%2F03%2FAndroid-HTMLViewer-%E6%89%93%E5%BC%80-txt%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Android HTMLViewer 打开.txt显示乱码 具体修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317 public class HTMLViewerActivity extends Activity &#123; private static final String TAG = &quot;HTMLViewer&quot;; private WebView mWebView; private View mLoading; /// M: add auto-detector for HTML viewer private static final String ENCODING_AUTO_DETECTED = &quot;auto-detector&quot;; private static final int HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE = 1; private Intent mRCVDIntent; private String mEncodingType=&quot;&quot;; static final int MAXFILESIZE = 1024 * 1024 * 8; private void processRcvdIntent() &#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); // Javascript is purposely disabled, so that nothing can be // automatically run. s.setJavaScriptEnabled(false); /// M: add auto-detector for HTML viewer //s.setDefaultTextEncodingName(&quot;utf-8&quot;); s.setDefaultTextEncodingName(ENCODING_AUTO_DETECTED); if (mRCVDIntent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(mRCVDIntent.getStringExtra(mRCVDIntent.EXTRA_TITLE)); &#125; mWebView.loadUrl(String.valueOf(mRCVDIntent.getData())); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mRCVDIntent = getIntent(); if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; Log.d(TAG, &quot;checkSelfPermission return false&quot;); requestPermissions(new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE); return; &#125; // processRcvdIntent(); //ovvi ovviIntent(savedInstanceState); Log.d(TAG, &quot;ovvi--------------------Intent&quot;); &#125; @Override public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; Log.d(TAG, &quot;onRequestPermissionsResult&quot;); switch (requestCode) &#123; case HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //ovvi begin ningshuran 20160718 change enter the first gibberish ovviIntent(); //end &#125; else &#123; Log.d(TAG, &quot;onRequestPermissionsResult return PERMISSION NOT GRANTED&quot;); Toast.makeText(getApplicationContext(), getResources() .getString(com.mediatek.R.string.denied_required_permission), Toast.LENGTH_LONG).show(); finish(); &#125; break; default: //do nothing &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mWebView != null) &#123; mWebView.destroy(); &#125; &#125; private class ChromeClient extends WebChromeClient &#123; @Override public void onReceivedTitle(WebView view, String title) &#123; if (!getIntent().hasExtra(Intent.EXTRA_TITLE)) &#123; HTMLViewerActivity.this.setTitle(title); &#125; &#125; &#125; private class ViewClient extends WebViewClient &#123; @Override public void onPageFinished(WebView view, String url) &#123; mLoading.setVisibility(View.GONE); &#125; @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123; final Uri uri = request.getUrl(); if (ContentResolver.SCHEME_FILE.equals(uri.getScheme()) &amp;&amp; uri.getPath().endsWith(&quot;.gz&quot;)) &#123; Log.d(TAG, &quot;Trying to decompress &quot; + uri + &quot; on the fly&quot;); try &#123; final InputStream in = new GZIPInputStream( getContentResolver().openInputStream(uri)); final WebResourceResponse resp = new WebResourceResponse( getIntent().getType(), &quot;utf-8&quot;, in); resp.setStatusCodeAndReasonPhrase(200, &quot;OK&quot;); return resp; &#125; catch (IOException e) &#123; Log.w(TAG, &quot;Failed to decompress; falling back&quot;, e); &#125; &#125; return null; &#125; &#125; /* ovvi begin add */ public void ovviIntent(Bundle savedInstanceState)&#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); s.setJavaScriptEnabled(false); s.setDefaultTextEncodingName(&quot;utf-8&quot;); if (savedInstanceState != null) &#123; mEncodingType = savedInstanceState.getString(&quot;EncodingType&quot;); if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; mWebView.restoreState(savedInstanceState); &#125; else &#123; final Intent intent = getIntent(); if (intent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(intent.getStringExtra(Intent.EXTRA_TITLE)); &#125; if (intent.getData() != null) &#123; Uri uri = intent.getData(); if (intent.getType().equals(&quot;text/plain&quot;)) &#123; try &#123; mEncodingType = codeString(uri.getPath()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; &#125; if (&quot;file&quot;.equals(uri.getScheme())) &#123; File file = new File(uri.getPath()); long len = file.length(); Log.v(TAG, &quot;len = &quot; + len); if (len &gt; MAXFILESIZE) &#123; showMessage(); return; &#125; &#125; mWebView.loadUrl(uri.toString()); &#125; &#125; &#125; private String codeString(String fileName) throws Exception &#123; BufferedInputStream bin = null; int p = 0; try &#123; bin = new BufferedInputStream(new FileInputStream(fileName)); p = (bin.read() &lt;&lt; 8) + bin.read(); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;IOException when get encode type&quot;, e); &#125; finally &#123; if(bin != null) bin.close(); &#125; String code = null; switch (p) &#123; case 0xefbb: code = &quot;UTF-8&quot;; break; case 0xfffe: code = &quot;Unicode&quot;; break; case 0xfeff: code = &quot;UTF-16BE&quot;; break; case 0x5c75: code = &quot;ANSI|ASCII&quot;; break; default: code = &quot;GBK&quot;; &#125; return code; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putString(&quot;EncodingType&quot;, mEncodingType); //ovvi begin ningshuran 20160712 if(mWebView!=null)&#123; Log.d(&quot;ovvi-----------------null&quot;, &quot;mWebView,is&apos;t null&quot;); mWebView.saveState(outState); &#125; //end &#125; private void showMessage() &#123; AlertDialog.Builder build = new AlertDialog.Builder(this).setTitle(R.string.app_label); build.setIcon(android.R.drawable.ic_dialog_alert); build.setMessage(R.string.file_size); build.setCancelable(true); build.setOnDismissListener(new DialogInterface.OnDismissListener()&#123; @Override public void onDismiss(DialogInterface dialog) &#123; finish(); &#125; &#125;); build.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;).show(); &#125; /* ovvi end */ /* ovvi begin ningshuran 20160718 add */ public void ovviIntent()&#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); s.setJavaScriptEnabled(false); s.setDefaultTextEncodingName(&quot;utf-8&quot;); final Intent intent = getIntent(); if (intent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(intent.getStringExtra(Intent.EXTRA_TITLE)); &#125; if (intent.getData() != null) &#123; Uri uri = intent.getData(); if (intent.getType().equals(&quot;text/plain&quot;)) &#123; try &#123; mEncodingType = codeString(uri.getPath()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; &#125; if (&quot;file&quot;.equals(uri.getScheme())) &#123; File file = new File(uri.getPath()); long len = file.length(); Log.v(TAG, &quot;len = &quot; + len); if (len &gt; MAXFILESIZE) &#123; showMessage(); return; &#125; &#125; mWebView.loadUrl(uri.toString()); &#125; &#125;//end &#125;]]></content>
      <categories>
        <category>Android HTMLViewer</category>
      </categories>
      <tags>
        <tag>Android HTMLViewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email com.android.email.service.EmailBroadcastProcessorService模块MemLeak异常]]></title>
    <url>%2F2016%2F04%2F30%2FAndroid-Email-com-android-email-service-EmailBroadcastProcessorService%E6%A8%A1%E5%9D%97MemLeak%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Android Email com.android.email.service.EmailBroadcastProcessorService模块MemLeak异常从源码上分析，服务已经是解绑了，为什么还会报这个异常，确实很奇怪 解决结论：EmailBroadcastProcessorService是一个IntentService，在这个service中尝试绑定到EasService 并获得返回值,随后启动了一个异步线程执行后台任务，当后台任务执行完成后，会调用unbindservie。IntentService在handlerintent 执行完成后立即销毁，并检查是否有依然绑定的服务，如果有则unbind,并打印警告，由于异步线程此时尚未执行完成，因此打印出了问题描述中的LOG。实际业务流程中，并不会再次用到绑定的服务。因此这个警告不会造成实际的影响(泄露或其他问题)。建议不做修改。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Downloaded files doesnot store in SD card]]></title>
    <url>%2F2016%2F04%2F28%2FAndroid-Downloaded-files-doesnot-store-in-SD-card%2F</url>
    <content type="text"><![CDATA[Android Downloaded files doesnot store in SD card[Current status]Open Setting &gt; Storage and USB &gt; select the SD card storage. Downloaded files doesnot store in SD card.[Expected result]It should be needed to store in Sd card when selected. Google kK版本之后是不允许第三方app 写外置sdcard的，所以自然app 无法download 到sdcard上。 (在setting中的默认存储设定为SD card，为MTK扩展的功能，只能影响到内置AP，比如说内置Camera,而Chrome属于3rd party apk，他并不会去拿storageManagerEx中扩展接口获取default storage path) project 是否需要过cts？如果要过cts，就不能改，因为cts 会测这个case，cts 不允许3rd app写sdcard，不然会fail。 如果项目不需要过cts,按以下方法修改： 请找到 mediatek/config/mt6732/init.ssd.rc 和 init.ssd_nomuser.rc 和 init.no_ssd.rc ， 找到文件中的 service fuse_sdcard1 /system/bin/sdcard -u 1023 -g 1023 -w 1023 -d /mnt/media_rw/sdcard1 /storage/sdcard1class late_startdisabled 改为service fuse_sdcard1 /system/bin/sdcard -u 1023 -g 1023 -d /mnt/media_rw/sdcard1 /storage/sdcard1class late_startdisabled 将-w 1023 去掉后 new build 测试。这样会造成cts 不过，因为更改了系统的fuse管理机制。这样可以写sdcard。 说明下：由于不知道使用的config的情况，所以建议3个 init.xx.rc 都修改]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email附件丢失]]></title>
    <url>%2F2016%2F04%2F25%2FAndroid-Email%E9%99%84%E4%BB%B6%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[Android Email附件丢失问题进入qq邮箱转发有附件的邮件到163邮箱，手机端丢失附件，电脑端显示有 1，附件同名，大小不同或者附件不同名，大小不同，QQ邮箱都可以完整接收附件2，附件同名，大小不同163邮箱不能完整接收，只能显示一个，丢失一个。附件不同名，163邮箱可以完整接收。 本问题是google原生设计如此，结合问题描述分析如下：1） QQ邮箱可以完整接收相同附件 — 目前QQ邮箱默认以imap方式登陆，email端对imap类型的邮箱没有做附件去重处理，故而能全部接收2） 163邮箱不能完整接收 — 目前163邮箱默认pop3方式登陆，对与pop3类型的邮箱，email端会对附件做去重处理，通过判断其FileName，MimeType，ContentId，及Location是否相同来断定是否为相同的附件，通过判断的条件可以看出没有对附件大小进行判断，所以测试中同名而大小不一的附件不会视为同一附件，故而能全部接收 解决方案：舍去pop3的附件去重处理]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email的简单分析]]></title>
    <url>%2F2016%2F04%2F20%2FAndroid-Email%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android Email的简单分析我看的是5.0Email的源码，看了几天AndroidEmail,不知道这些小图标是哪个类提供的 搜索了好久都没有找到，网上对Email的分析也少。最后我才发现这些小图标，包括下拉刷新等都是UnifiedEmail提供的，相当于UI就是邮件的一些界面，收件箱，抽屉实现，还有详细信息显示，编辑邮箱界面都在这里面，相当于一个jar包。还有一个Exchange里面是Email的一些服务。Email最重要的就是账户信息的处理和协议方面。Email引用Unified是通过Android.mk引用的。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser页面字体设置过大时，字体重叠]]></title>
    <url>%2F2015%2F11%2F28%2FAndroid-Browser%E9%A1%B5%E9%9D%A2%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E8%BF%87%E5%A4%A7%E6%97%B6%EF%BC%8C%E5%AD%97%E4%BD%93%E9%87%8D%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[Android Browser 字体重叠Browser在设置-辅助功能-文子缩放和字体大小下限设置为最大时，会导致字体重叠显示不全。 原因分析：网页文字出现重叠的主要是网页排版的原因，网页CSS样式限定了行高，当宽度不够或字体较大情况下，显示区域就会重叠。由于浏览器无法对写死的的行高进行调整，所以在行高限定的网页中字体过大出现显示问题是正常的。这不是浏览器的问题。 解决方案：当需要调小字体时，在BrowserSettings.java syncStaticSettings中，可以设置默认字体大小， settings.setDefaultFontSize(16); settings.setDefaultFixedFontSize(13); 可以修改减小参数， 当需要调小字体缩放 1234567891011121314private Runnable mSetup = new Runnable() &#123;&#125; switch (getTextSize()) &#123; case SMALLEST: setTextZoom(50); break; case SMALLER: setTextZoom(75); break; case LARGER: setTextZoom(150); break; case LARGEST: setTextZoom(200); break; 其实修改了这些参数依然会出现不能修改字体缩放的作用。 12345678910//控制字体大小上下限范围private static final int MIN_FONT_SIZE_OFFSET = 5; private static final int TEXT_ZOOM_START_VAL = 10; //控制字体缩放范围 private static final int TEXT_ZOOM_STEP = 5;//控制双击缩放 private static final int DOUBLE_TAP_ZOOM_START_VAL = 5; private static final int DOUBLE_TAP_ZOOM_STEP = 5; 修改了这里的参数才会真正改变初始的值，从而达到调小缩放范围的目的。同时需要在Layout修改progressbar的值 导致这个问题真正的原因是goolge webview。从百度页面-&gt;进如美食-&gt;进入百度糯米，发现美团的页面的字体少一半。进入糗事百科。设置显示为桌面版（显示效果跟电脑打开网页效果一样），字体重叠现象。都是goolge webview导致的。这是因为4.4之后取消了字体重排 ？？]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser网络状态判断]]></title>
    <url>%2F2015%2F10%2F27%2FAndroid-Browser%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[Android Browser网络状态的判断NetworkStateHandler的构造方法里面就有网络状态的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NetworkStateHandler &#123; Activity mActivity; Controller mController; // monitor platform changes private IntentFilter mNetworkStateChangedFilter; private BroadcastReceiver mNetworkStateIntentReceiver; private boolean mIsNetworkUp; public NetworkStateHandler(Activity activity, Controller controller) &#123; mActivity = activity; mController = controller; // Find out if the network is currently up. ConnectivityManager cm = (ConnectivityManager) mActivity .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = cm.getActiveNetworkInfo(); if (info != null) &#123; mIsNetworkUp = info.isAvailable(); if (Util.SUPPORT_NAVIGATION_TAB)&#123; DownloadFavicon.setNetworkUp(mIsNetworkUp); &#125; &#125; /* * enables registration for changes in network status from http stack */ mNetworkStateChangedFilter = new IntentFilter(); mNetworkStateChangedFilter.addAction( ConnectivityManager.CONNECTIVITY_ACTION); mNetworkStateIntentReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals( ConnectivityManager.CONNECTIVITY_ACTION)) &#123; NetworkInfo info = intent.getParcelableExtra( ConnectivityManager.EXTRA_NETWORK_INFO); String typeName = info.getTypeName(); String subtypeName = info.getSubtypeName(); sendNetworkType(typeName.toLowerCase(), (subtypeName != null ? subtypeName.toLowerCase() : &quot;&quot;)); BrowserSettings.getInstance().updateConnectionType(); boolean noConnection = intent.getBooleanExtra( ConnectivityManager.EXTRA_NO_CONNECTIVITY, false); onNetworkToggle(!noConnection); &#125; &#125; &#125;; &#125; 我自己则写了一个网络判断的方法 12345678910public boolean checkNetworkInfo() &#123; ConnectivityManager conMan = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE); State mobile = conMan.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState(); State wifi = conMan.getNetworkInfo(ConnectivityManager.TYPE_WIFI).getState(); if (mobile == State.CONNECTED || mobile == State.CONNECTING) return true; if (wifi == State.CONNECTED || wifi == State.CONNECTING) return true; return false; &#125;]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser打开网页为源码原因分析]]></title>
    <url>%2F2015%2F09%2F29%2FAndroid-Browser%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E4%B8%BA%E6%BA%90%E7%A0%81%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android Browser打开网页出现源码有这样的现象，使用数据流量打开网页会出现网页源码的现象，而使用WIFI打开网页则正常显示，使用WIFI后再用数据流量打开，也能正常显示。 这样的现象多半是因为数据传输时出现中断等情况，导致网页没有加载完整，所以显示异常。 还有的是因为GMS版本用的是google webview，原生的webview不支持WML页面，这个现象是正常的。现在已经极少有WML的网站。使用支持WML页面的webview则能正常显示。 Wifi上网，服务器返回html网页；gprs上网，服务器返回wml网页；这是移动门户网站的处理，网站并没有考虑到不支持wml网页的情况。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser打开多个窗口进行切换会闪烁]]></title>
    <url>%2F2015%2F09%2F01%2FAndroid-Browser%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2%E4%BC%9A%E9%97%AA%E7%83%81%2F</url>
    <content type="text"><![CDATA[Android Browser打开多个窗口进行切换会闪烁原因分析浏览器的多标签切换功能, 还需要一个用户交互界面, 这个界面在Android Browser中就是NavScreen了 在Android Browser中 用以和用户打交道的功能基本都被限制在了BaseUI中, 在手机上它的实现就是PhoneUI 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//点击按钮显示多窗口列表 void showNavScreen() &#123; mUiController.setBlockEvents(true); //拦截多窗口外的其他操作 if (mNavScreen == null) &#123; mNavScreen = new NavScreen(mActivity, mUiController, this); mCustomViewContainer.addView(mNavScreen, COVER_SCREEN_PARAMS); &#125; else &#123; mNavScreen.setVisibility(View.VISIBLE); mNavScreen.setAlpha(1f); mNavScreen.refreshAdapter(); &#125; mActiveTab.capture(); if (mAnimScreen == null) &#123; //这是动画的视图 ,多标签窗口切换的动画是phoneui来实现的而不是 navscreen ,也就是说我点击一个tab 剩下的看到的其实是 //真正的web窗口 mAnimScreen = new AnimScreen(mActivity); &#125; else &#123; mAnimScreen.mMain.setAlpha(1f); mAnimScreen.mTitle.setAlpha(1f); mAnimScreen.setScaleFactor(1f); &#125; //设置动画需要截图的view mAnimScreen.set(getTitleBar(), getWebView()); if (mAnimScreen.mMain.getParent() == null) &#123; //如果animscreen 的main没有父亲, 说明是执行了 全屏模式 mCustomViewContainer.addView(mAnimScreen.mMain, COVER_SCREEN_PARAMS); &#125; mCustomViewContainer.setVisibility(View.VISIBLE); mCustomViewContainer.bringToFront();//把这个view放到顶层 mAnimScreen.mMain.layout(0, 0, mContentView.getWidth(), mContentView.getHeight()); //动画的宽度和contentview一样大 int fromLeft = 0; int fromTop = getTitleBar().getHeight(); int fromRight = mContentView.getWidth(); int fromBottom = mContentView.getHeight(); int width = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_width); int height = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_height); int ntth = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_titleheight); int toLeft = (mContentView.getWidth() - width) / 2; int toTop = ((fromBottom - (ntth + height)) / 2 + ntth); int toRight = toLeft + width; int toBottom = toTop + height; float scaleFactor = width / (float) mContentView.getWidth(); detachTab(mActiveTab); mContentView.setVisibility(View.GONE); AnimatorSet set1 = new AnimatorSet(); AnimatorSet inanim = new AnimatorSet(); //使用上下左右的位置 使得 tab的运动轨迹 从整个屏幕 位置缩小到tab,无论当前tab在哪里 ObjectAnimator tx = ObjectAnimator.ofInt(mAnimScreen.mContent, "left", fromLeft, toLeft); ObjectAnimator ty = ObjectAnimator.ofInt(mAnimScreen.mContent, "top", fromTop, toTop); ObjectAnimator tr = ObjectAnimator.ofInt(mAnimScreen.mContent, "right", fromRight, toRight); ObjectAnimator tb = ObjectAnimator.ofInt(mAnimScreen.mContent, "bottom", fromBottom, toBottom); ObjectAnimator title = ObjectAnimator.ofFloat(mAnimScreen.mTitle, "alpha", 1f, 0f); ObjectAnimator sx = ObjectAnimator.ofFloat(mAnimScreen, "scaleFactor", 1f, scaleFactor); //这个动画是透明动画 ObjectAnimator blend1 = ObjectAnimator.ofFloat(mAnimScreen.mMain, "alpha", 1f, 0f); blend1.setDuration(100); inanim.playTogether(tx, ty, tr, tb, sx, title); inanim.setDuration(200); set1.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator anim) &#123; mCustomViewContainer.removeView(mAnimScreen.mMain); finishAnimationIn(); mUiController.setBlockEvents(false); &#125; &#125;); set1.playSequentially(inanim, blend1);//inanim播放ok后播放 blend1 也就是先缩放然后在透明 set1.start(); &#125; 看了代码，发现动画有个透明效果的动画。研究之后才发现，其实浏览器切换并不是“闪烁”，而是一个透明动画，这个动画造成了“闪烁”的现象，把这个动画去掉后，可以发现闪烁的现象没有了，而且切换窗口的时候更加平滑。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
</search>
