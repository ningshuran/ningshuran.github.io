<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android-7.0 蓝牙MAC获取]]></title>
    <url>%2F2017%2F12%2F15%2FAndroid-7.0%20%E8%93%9D%E7%89%99MAC%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Android-7.0 蓝牙MAC获取今天修改一个关于写入蓝牙MAC显示与写入不符，且之后的写入都显示都不能正常写入，但写号工具能正常显示的问题。 打入一个高通补丁之后，第一次写号可以写入，工具和机器都正常显示，但之后的写入，工具显示正常，但机器一直显示为第一次写入。 未修改方法： BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); ; String addressStr = mBluetoothAdapter.getAddress(); android 6.0之后是一个大的变化，所以以前的很多方法并不适用了，Android6.0以上为了给用户更多的数据保护，无法访问WiFi和蓝牙的mac地址，通过BluetoothAdapter.getDefaultAdapter().getAddress()获取的地址是一个固定值02:00:00:00:00:00，在一个运行 Android 6.0 (API 级别 23) 的设备初始化后台的 WiFi 或蓝牙扫描时，操作对于外部设备是可见的，且被赋予一个随机的 MAC 地址。 修改方法一： 直接拿路径address获取 /sys/class/net/wlan0/address /sys/class/net/eth0/address adb进入我的小米手机查看对应路径address，打开看正是MAC地址 故 /* &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; */ public static String getMac() { String str = &quot;&quot;; String macSerial = &quot;&quot;; try { Process pp = Runtime.getRuntime().exec( &quot;cat /sys/class/net/wlan0/address &quot;); InputStreamReader ir = new InputStreamReader(pp.getInputStream()); LineNumberReader input = new LineNumberReader(ir); for (; null != str; ) { str = input.readLine(); if (str != null) { macSerial = str.trim(); break; } } } catch (Exception ex) { ex.printStackTrace(); } if (&quot;&quot;.equals(macSerial)) { try { return loadFileAsString(&quot;/sys/class/net/eth0/address&quot;) .toUpperCase().substring(0, 17); } catch (Exception e) { e.printStackTrace(); } } return macSerial; } private static String loadFileAsString(String fileName) throws Exception { FileReader reader = new FileReader(fileName); String text = loadReaderAsString(reader); reader.close(); return text; } private static String loadReaderAsString(Reader reader) throws Exception { StringBuilder builder = new StringBuilder(); char[] buffer = new char[4096]; int readLength = reader.read(buffer); while (readLength &gt;= 0) { builder.append(buffer, 0, readLength); readLength = reader.read(buffer); } return builder.toString(); } 修改后，没用！adb进入手机查看竟然没有对应的路径，所以该方法只能部分机器获取。 public static String getMac(Context context) { return android.provider.Settings.Secure.getString(context.getContentResolver(), &quot;bluetooth_address&quot;); } 有人用此方法获得华为mate 9（7.0）蓝牙MAC 修改方法二： 有人给出stackoverflow上的方法 private String getBtAddressViaReflection() { BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); Object bluetoothManagerService = new Mirror().on(bluetoothAdapter).get().field(&quot;mService&quot;); if (bluetoothManagerService == null) { Log.w(TAG, &quot;couldn&apos;t find bluetoothManagerService&quot;); return null; } Object address = new Mirror().on(bluetoothManagerService).invoke().method(&quot;getAddress&quot;).withoutArgs(); if (address != null &amp;&amp; address instanceof String) { Log.w(TAG, &quot;using reflection to get the BT MAC address: &quot; + address); return (String) address; } else { return null; } } 工程需要添加对net.vidageek:mirror的引用 compile &apos;net.vidageek:mirror:1.6.1&apos; 用此方法写个Demo确实能正确引用 要添加包的引用，这又是个问题 后来得知添加了NV不能二次写入的机制 1.之前是請tools team 在更改 bt mac addr (nv447) 時，必須把 persist下面的 /.bt_nv.bin也一併刪除。(需root 權限) 2.如果上述1 方法失敗的話，就要嘗試改軟件了。vendor\qcom\proprietary\bt\hci_qcomm_init\Android.mk #If you want to use the legacy way(by using NV) of set the BT address #You can set the value to 0 BT_QSOC_GET_ITEMS_FROM_PROPERTY = 0 BT_QSOC_GET_ITEMS_FROM_PERSIST = 1 改為0 試試]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-7.0 IMEI获取]]></title>
    <url>%2F2017%2F12%2F14%2FAndroid-7.0%20IMEI%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[Android-7.0 IMEI反射获取今天修改一个关于IMEI显示为0的问题，写号工具写了IMEI号，用工具查看已经写入，但*#06#查看IMEI显示为0 未修改获取方式： TelephonyManager mTelephonyManager = (TelephonyManager) mActivity.getSystemService(Context.TELEPHONY_SERVICE); String imei1=mTelephonyManager.getDeviceId(0);//imei1 String imei2=mTelephonyManager.getDeviceId(1);//imei2 翻阅TelephonyManager.java源码得知，竟有getIMEI()方法,用IDE调用此方法发现不能调用，原来是隐藏的API。 /** * Returns the IMEI. Return null if IMEI is not available. * * &lt;p&gt;Requires Permission: * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} */ /** {@hide} */ public String getImei() { return getImei(getDefaultSim()); } /** * Returns the IMEI. Return null if IMEI is not available. * * &lt;p&gt;Requires Permission: * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE} * * @param slotId of which deviceID is returned */ /** {@hide} */ public String getImei(int slotId) { ITelephony telephony = getITelephony(); if (telephony == null) return null; try { return telephony.getImeiForSlot(slotId, getOpPackageName()); } catch (RemoteException ex) { return null; } catch (NullPointerException ex) { return null; } } 直接反射调用 private String getIMEI(int phoneid) { TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); Class&lt;TelephonyManager&gt; telephonyManagerClass = TelephonyManager.class; String deviceId = null; try { Method method = telephonyManagerClass.getMethod(&quot;getImei&quot;, new Class[]{int.class}); method.setAccessible(true); Object object = method.invoke(telephonyManager, phoneid); deviceId = (String)object; return deviceId; } catch (Exception e) { e.printStackTrace(); return null; } 但像这种隐藏API，拥有系统级权限android:sharedUserId=”android.uid.system 是可以直接调用编译通过的 TelephonyManager mTelephonyManager = (TelephonyManager) mActivity.getSystemService(Context.TELEPHONY_SERVICE); String imei1=mTelephonyManager.getIMEI(0);//imei1]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Toast的优化]]></title>
    <url>%2F2017%2F12%2F13%2FAndroid-Toast%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android-Toast的优化今天修改一个关于指纹录入的问题，每次录入都会弹Toast提示剩余次数 然后review时候竟然跟我说不行! 实际上很早以前就发现连续弹Toast每次弹一次都会等消失才显示第二个，确实存在体验问题。一直没有想过要优化Toast着实感觉惭愧。 一般Toast使用 Toast.makeText(this,&quot;&quot;,Toast.LENGTH_SHORT).show(); 翻阅Toast源码得知，了解到show()方法，每次通过handler发送异步任务，调用远程通知服务显示通知，每次show()一次弹一次，Toast实现其实是一个消息队列，在原有信息没有消失之前后来的信息都会等待。 故存在优化空间，在一次Toast显示时间段内，可多次改变显示内容。需要一个对象，在后续调用Toast时对其进行判断，如果系统中存在则只对其的内容进行设置，不存在则新建一个Toast。 单列优化 public static void show(Context context, String msg) { if (toast == null) { toast = Toast.makeText(context, msg, Toast.LENGTH_SHORT); } else { toast.setText(msg); } toast.show(); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-JNI的使用]]></title>
    <url>%2F2017%2F12%2F12%2FAndroid-JNI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android-JNI的使用什么jnijni java native interface 是一套协议，提供一套编程框架，java和本地语言之相互调用。 为什么需要jni操作系统下底层硬件，android下传感器程序运行效率有要求，图形渲染，音视频解码程序的安全性，用本地代实现核心逻辑使用成熟本地代码，Sqlite,OpenGL,OpenSSL,OpenCV,FFmpeg复用公司之前的本地代码 使用jni的前提熟练使java了解c的基本语法jni使用规范学习开发工具使用NDK jni开发流程阶段一 编码1.新建android工程，用natvie声明本地方法，调用本地方法 public class MainActivity extends Activity { static{ System.loadLibrary(&quot;getcstring&quot;);//写库名，不是库文件名 } //声明 native方法 private native String getCString(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //调用native方法 Toast.makeText(this, getCString() , Toast.LENGTH_SHORT).show(); } 2.工程中新建jni文件夹，新建getcstring.c源文件，包含jni.h头文件 #include &lt;jni.h&gt; /** * 实现本地方法对应的的c函数名:Java_包名_类名_本地方法名 * JNIEnv *env 代表java环境，提供各种函数 * jobject obj 调用本地方法类的对象 */ jstring Java_com_example_jnidemo_MainActivity_getCString(JNIEnv *env, jobject obj) { char buf[] = &quot;getstring from c!&quot;;//c字符数组保存字符串 //env : JNIEnv * &lt;=&gt; struct JNINativeInterface* * // (**env).NewStringUTF(); // (*env)-&gt;NewStringUTf(); //实现把c提供char *指向的字符串转换为java中String对象 //jstring (*NewStringUTF)(JNIEnv*, const char*); return (*env)-&gt;NewStringUTF(env, buf); } 阶段二 编译1.在jni文件夹下新建Android.mk指导编译的配置文件 LOCAL_PATH := $(call my-dir) #指定路径为当前目录 include $(CLEAR_VARS) #清除LOCAL_XXX,除了LOCAL_PATH LOCAL_MODULE := getcstring #指定最终生成的动态库名hello,生成的动态库文件名libgetcstring.so LOCAL_SRC_FILES := getcstring.c #指定生成目标用到所有源文件 include $(BUILD_SHARED_LIBRARY) #指定最终生成动态库 2.使用ndk-build.cmd进行编译，需要把ndk根路径添加到path环境变量3.进入jni文件夹，执行ndk-build编译，生成libgetcstring.so动态库，安装libs/armeabi/目录下 4.在调用本地方法类加载库 static{ System.loadLibrary(&quot;getcstring&quot;); } jni开发中错误及解决 找不到库：Caused by: java.lang.UnsatisfiedLinkError: Couldn’t load calc-jn1: findLibrary returned null 解决办法： 检查加载的库名和实际库名是否一致生成的动态库是为arm平生成，运行在x86处理器；在jni文件夹下添加Application.mk文件，写上APP_ABI := all 找不到方法： java.lang.UnsatisfiedLinkError: Native method not found: 解决办法： 本地方法对应本地函数名是否符合规范 没有加载动态库 Studio下加入 sourceSets { main { jniLibs.srcDirs = [&apos;libs&apos;] } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-蓝牙配对无提示音]]></title>
    <url>%2F2017%2F12%2F09%2FAndroid-%E8%93%9D%E7%89%99%E9%85%8D%E5%AF%B9%E6%97%A0%E6%8F%90%E7%A4%BA%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[Android-蓝牙配对无提示音\packages\apps\Settings\src\com\android\settings\bluetooth\BluetoothPairingDialog.java onCreate{ ... //add ************************** if (isCreated) { Uri notification = RingtoneManager.getDefault(RingtoneManager.TYPE_NOTIFICATION); Ringtone r = RingtoneManager.getRingtone(getApplicationContext(), notification); r.play(); } //end ************************** ... } 如果正在使用蓝牙听音乐，则可能出现音频焦点的问题。即在蓝牙听音乐时候，需要与其他设备进行配对操作，而触发配对提示音，则音乐会失去焦点暂停播放。 处理音频焦点的问题首先第一步要获得一个音频管理服务AudioManager mAudioManager = (AudioManager)getSystemService(AUDIO_SERVICE); 然后在合适的地方放置获得音频焦点的代码 mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN); 第三步实现音频焦点监听器OnAudioFocusChangeListener，这个监听器会根据当前音频焦点的变化，调用onAudioFocusChange(int focusChange)方法 最后在适当的时候注销掉这个监听器比如在onDestroy()中 mAudioManager.abandonAudioFocus(mAudioFocusListener); 完整的处理蓝牙无提示音问题 onCreate{ ... if (isCreated) { Uri notification = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); final Ringtone r = RingtoneManager.getRingtone(getApplicationContext(), notification); if (mAudioManager == null) { mAudioManager = (AudioManager) getApplicationContext().getSystemService(Context.AUDIO_SERVICE); } mAudioManager.requestAudioFocus(null, AudioManager.STREAM_SYSTEM, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); r.play(); Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { r.stop(); if (mAudioManager != null) { mAudioManager.abandonAudioFocus(null); } } }, 1000); } /* * Leave this registered through pause/resume since we still want to * finish the activity in the background if pairing is canceled. */ registerReceiver(mReceiver, new IntentFilter(BluetoothDevice.ACTION_PAIRING_CANCEL)); registerReceiver(mReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)); mReceiverRegistered = true; ... }]]></content>
      <categories>
        <category>Android Settings</category>
      </categories>
      <tags>
        <tag>Android Settings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-预编译]]></title>
    <url>%2F2017%2F11%2F28%2FAndroid-%E9%A2%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Android-预编译什么是ART http://www.jianshu.com/p/58f817d176b7 即Android RuntimeART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。 ART有什么优缺点呢？ 优点：1、系统性能的显著提升。2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。3、更长的电池续航能力。4、支持更低的硬件。缺点：1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%（不过在应用包中，可执行的代码常常只是一部分。比如最新的 Google+ APK 是 28.3 MB，但是代码只有 6.9 MB。）2.应用的安装时间会变长。 现在智能手机大部分都可以让用户选择使用Dalvik还是ART模式。当然默认还是使用Dalvik模式。用法：设置-辅助功能-开发者选项（开发人员工具）-选择运行环境 开机速度优化http://blog.csdn.net/u010164190/article/details/51463492 我们知道在L及以后的版本中,当系统升级后,或者恢复出厂设置后,或者第一次开机,其启动时间往往很长,短的有3-4分钟,而长的多达10分钟,那么是原因导致的,我们将分析其原因.我们知道,在Android的最初的几个版本,Android的app 运行在Dalvik中,完全是解释性执行.在Android2.2中,Google把JVM中常用的技术JIT带进了Dalvik,并且增加了多线程的处理能力.随着岁月的流失,科技的进步,屌丝用户期望的提高,手机厂商拼分数,拼情怀,拼硬件,跟踪赵氏族人的style.终于Android 手机的HW,从singlecore 到了8cores,10 cores. RAM 也从256M,512M, 1G, 2G, 3G 到6G.内部存储也从256M到了128G,256G.Google也顺应潮流,终于在L 中,正式推出ART. dex文件优化发生的时机优化发生的时机有两个： 1、对于预置应用，可以在系统编译后，生成优化文件，以ODEX 结尾。这样在发布时除 APK 文件（不包含 DEX）以外，还有一个相应的 ODEX 文件； 2、对于非预置应用，包含在 APK 文件里的 DEX 文件会 a、user/userdebug版本：在安装时进行dex优化 b、eng版本：在运行时通过dexopt进行优化 优化后的文件将被保存在缓存中(data/dalvik-cache) 如何提高首次开机速度?http://blog.csdn.net/croop520/article/details/73930184 开机过程中会去做odex优化，这样会加长开机时间，我们将其更改为编译时做odex优化 1、 在device/sprd/scx35/BoardConfigCommon.mk WITH_DEXPREOPT := false修改如下： ifeq ($(TARGET_BUILD_VARIANT),user) ifeq ($(WITH_DEXPREOPT),) WITH_DEXPREOPT := true WITH_DEXPREOPT_PIC := true endif endif # TODO, so much prebuilts in GMS, needs a better solution to control # the multi-dex condiction DONT_DEXPREOPT_PREBUILTS := false 注： 1、true后面一定不要有空格 2、DONT_DEXPREOPT_PREBUILTS为false表示对Android.mk中含有include $(BUILD_PREBUILT)的apk在编译时做odex优化，为true则编译时不会做odex优化，主要影响三方apk和gms包，具体可以根据实际需求做选择 2、删除telephony-common2的编译选项，否则可能会编译报错 具体路径是对应的编译工程的目录下，如下： device/sprd/scx35l/features/base/config.mk PRODUCT_BOOT_JARS += \ telephony-common2 FEATURES.PRODUCT_PACKAGES += \ telephony-common2 3、打开编译时odex优化，会加大system分区的大小，所以要修改system分区大小，具体如下：文件目录：device/sprd/scx35*（或其他对应的编译型号）/BoardConfig.mk 修改BOARD_SYSTEMIMAGE_PARTITION_SIZE和BOARD_USERDATAIMAGE_PARTITION_SIZE值的大小，使得这两部分的和和原来大小一样。 如何让预制应用不做odex处理？user版本默认会对系统和预制应用做odex处理，而某些第三方应用在odex处理后会出现无法启动、登陆的问题。此时可以修改这些应用的make文件加上LOCAL_DISABLE_DEX_PREOPT := true。 include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := xxx.apk LOCAL_MODULE_CLASS := APPS LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_PATH := $(TARGET_OUT)/preloadapp LOCAL_SRC_FILES := xxx.apk + LOCAL_DISABLE_DEX_PREOPT := true include $(BUILD_PREBUILT) WITH_DEXPREOPT我们可以在BoardConfig.mk里定义 WITH_DEXPREOPT := true 这样整个system image 就会被预先优化. 由于在启动时不再需要进行app的dex文件进行优化(dex2oat操作)从而提升其启动速度. DONT_DEXPREOPT_PREBUILTS如果我们不想把prebuilts目录中的第三方应用进行预先优化(这些应用在他们的Android.mk文件中有include$(BUILD_PREBUILT) ).而是希望这些app通过playstore 或者app提供商进行升级.我们需要在BoardConfig.mk里进行如下的定义. WITH_DEXPREOPT :=true DONT_DEXPREOPT_PREBUILTS := true WITH_DEXPREOPT_BOOT_IMG_ONLY这个选项只是把boot image 进行预先优化.简单来说,其主要生成boot.art 和boot.oat.这能显著的减少systemimage 大小.但是,所有的app 都需要在第一次启动的时候进行优化需要花更长的boottime 时间.我们需要在BoardConfig.mk里进行如下的定义 WITH_DEXPREOPT :=true WITH_DEXPREOPT_BOOT_IMG_ONLY := true LOCAL_DEX_PREOPT我们也可以控制单个APP是否需要预先优化.如果我们的APP是通过Google play 来进行升级的,或者为了平衡空间问题,我们可以在app的Android.mk 中设置如下属性. LOCAL_DEX_PREOPT :=false // 不进行预先优化 LOCAL_DEX_PREOPT :=true // 进行预先优化 WITH_DEXPREOPT_PIC我们知道ART 在system 有一份OAT file ,在运行时也会copy 一份到/data/ dalvik-cache下.如果我们内部存储不够,可以enable这个选项.但是这个选项可能会影响运行时的性能.因为ART 会disable和position相关的优化.在device.mk 中添加, WITH_DEXPREOPT :=true WITH_DEXPREOPT_PIC :=true WITH_ART_SMALL_MODE如果手机没有足够的空间,我们可以enable 这个宏.ART只会预先优化boot class.第一次启动的时间会大大的提升,但是也会大大影响运行时性能.因为其它的appcode 是解释性执行的.在device.mk中添加, WITH_ART_SMALL_MODE :=true 在Android 后面的版本中也许会修改成 device.mk: PRODUCT_PROPERTY_OVERRIDES +=\ dalvik.vm.dex2oat-filter=interpret-only \ dalvik.vm.image-dex2oat-filter=speed]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-一些修改201711]]></title>
    <url>%2F2017%2F11%2F22%2FAndroid-%E4%B8%80%E4%BA%9B%E4%BF%AE%E6%94%B9201711%2F</url>
    <content type="text"><![CDATA[Android 一些修改201711[QUESTION] [时钟]设置5秒以内的倒计时,时间到后都会在第5秒开始响铃 [ANSWER] 这是因为倒计时开始之后，要等待接收AlarmManager的timers_up广播，而5.1原生AlarmManager的设计“5秒之内的都会调整到5秒的时间点上”上层闹钟应用在设置一个action = times_up 的定时器下来的时候，到Framework层，会有相关判断 在AlarmManagerService.java中 final long nowElapsed = SystemClock.elapsedRealtime(); final long nominalTrigger = convertToElapsed(triggerAtTime, type); // Try to prevent spamming by making sure we aren&apos;t firing alarms in the immediate future final long minTrigger = nowElapsed + MIN_FUTURITY; //MIN_FUTURITY =5 ×1000 final long triggerElapsed = (nominalTrigger &gt; minTrigger) ? nominalTrigger : minTrigger; 这段代码说明，如果当前设置的alarm时间点低于5s的时候，会以最小的5s作为触发事件设置到底层。 所以会出现上层alarm应用：即使设置小于5s的定时器，触发的时间同样是5s [SOLUTION] \frameworks\base\services\core\java\com\android\server\AlarmManagerService.java // Try to prevent spamming by making sure we aren&apos;t firing alarms in the immediate future //去掉MIN_FUTURITY5秒 final long minTrigger = nowElapsed ; [QUESTION] [记事本]编辑记事本时低电至自动关机，开机后列表中有个空的记事本 [ANSWER] NoteEditor.java每次进去编辑模式都会插入一条空的数据 onCreate(){ // Sets the Activity state to INSERT, gets the general note URI, and // inserts an // empty record in the provider mState = STATE_INSERT; //onCreate 每次进去都会向数据库插入一条空数据 mUri = getContentResolver().insert(intent.getData(), null); setResult(RESULT_OK, (new Intent()).setAction(mUri.toString())); Log.d(TAG, &quot;SetResult for EditNote&quot;); } 所以在编辑还没更新数据时都会保存一条空的数据 [SOLUTION] NotesList.java public void UpdateAdapterData() { StringBuilder path = new StringBuilder(); muri = Uri.withAppendedPath(Notes.CONTENT_URI, path.toString()); if (mCursorNotepad != null) { mCursorNotepad.close(); mCursorNotepad = null; } //begin modified 查询数据库时只要是COLUMN_NAME_NOTE是“ ”就不显示出来，在这里过滤掉 mCursorNotepad = getContentResolver().query(muri, PROJECTION, Notes.COLUMN_NAME_NOTE+&quot;!=&apos;&apos;&quot;, null, null); //end modified if (mCursorNotepad != null) { mListAdapter = new MyListViewAdapter(this, mCursorNotepad); mListView.setAdapter(mListAdapter); } } [QUESTION] [多媒体]开机后打开音乐加载MP3过慢 [ANSWER] frameworks\base\media\java\android\media\MediaScanner.java: public void scanDirectories(String[] directories, String volumeName) { ... // create MediaInserter for bulk inserts mMediaInserter = new MediaInserter(mMediaProvider, mPackageName, 500); //收集到500条数据，MediaInserter批量插入一次 ... } frameworks\base\media\java\android\media\MediaInserter.java private void insert(Uri tableUri, ContentValues values, boolean priority) throws RemoteException { ...... if (list.size() &gt;= mBufferSizePerUri) { // mBufferSizePerUri即为500，当存放数据的list不小于500时，执行批量插入 flushAllPriority(); flush(tableUri, list); } } 当音乐文件总数小于500时，音乐文件的插入将在扫描的最后执行。导致在扫描过程中，音乐列表不显示音乐文件。 此时可以减小每次批量插入的数量，较早地插入数据库，音乐列表较早得到数据。 [SOLUTION] frameworks\base\media\java\android\media\MediaInserter.java //add ********** private final Uri mAudioUri = Audio.Media.getContentUri(&quot;external&quot;); private final Uri mVideoUri = Video.Media.getContentUri(&quot;external&quot;); private final Uri mImagesUri = Images.Media.getContentUri(&quot;external&quot;); ... private void insert(Uri tableUri, ContentValues values, boolean priority) throws RemoteException { ... //begin add ********** if (mAudioUri.equals(tableUri ) || mVideoUri.equals(tableUri )) { if (list.size() &gt;= 100) { Log.v(&quot;mediaInserter&quot;, &quot;list.size() &gt;= 100&quot;); flushAllPriority(); flush(tableUri, list); } } else if (mImagesUri.equals(tableUri)) { if (list.size() &gt;= 200) { Log.v(&quot;mediaInserter&quot;, &quot;list.size() &gt;= 200&quot;); flushAllPriority(); flush(tableUri, list); } //end add ********** } else if (list.size() &gt;= mBufferSizePerUri) { flushAllPriority(); flush(tableUri, list); } ... } [QUESTION] [相机]内存空间已满，进入相机报停 [ANSWER] java.io.IOException: write failed: ENOSPC (No space left on device) [SOLUTION] onCreate｛ //begin modified //获得可用内存 StorageManager storageManager = this.getSystemService(StorageManager.class); final List&lt;VolumeInfo&gt; volumes = storageManager.getVolumes(); long privateFreeBytes = 0; for (VolumeInfo info : volumes) { if (info.getType() != VolumeInfo.TYPE_PUBLIC &amp;&amp; info.getType() != VolumeInfo.TYPE_PRIVATE) { continue; } final File path = info.getPath(); privateFreeBytes = path.getFreeSpace(); } Log.d(TAG,&quot;add for hipad -----&quot;+privateFreeBytes+&quot;-----&quot;); //LOW_STORAGE_THRESHOLD_BYTES 原为5000000 可根据实际修改 if (privateFreeBytes &lt;= Storage.LOW_STORAGE_THRESHOLD_BYTES) { //弹出提示 final AlertDialog.Builder alertdialog = new AlertDialog.Builder(this); alertdialog.setTitle(R.string.dialog_low_storage_title); alertdialog.setMessage(R.string.dialog_low_storage_message); alertdialog.setCancelable(false); alertdialog.setPositiveButton(R.string.dialog_low_storage_ok, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { //点击确定直接finish finish(); } }); alertdialog.show(); } //end modified ｝ [QUESTION] [设置]受损的音频能设置为来电铃声 [SOLUTION] \packages\providers\MediaProvider\src\com\android\providers\media\SdcardRingtonePickerActivity.java 1234567891011121314151617181920212223242526272829303132333435//addprivate boolean mCanPlay = true;private DialogInterface.OnClickListener mRingtoneClickListener = new DialogInterface.OnClickListener() &#123; /* * On item clicked */ public void onClick(DialogInterface dialog, int which) &#123; ... if(title2.equals(title))&#123; //begin modified ************** MediaPlayer mediaPlayer = new MediaPlayer(); try &#123; mediaPlayer.setDataSource(mContext, uri); mediaPlayer.prepare(); ringtone.play(); mCanPlay = true; &#125; catch (Exception e) &#123; mCanPlay = false; Toast toast = Toast.makeText(this, R.string.ringtone_default_message,Toast.LENGTH_SHORT); toast.show(); &#125; finally &#123; mediaPlayer.reset(); mediaPlayer.release(); mediaPlayer = null; &#125; //end modified ************** &#125; else &#123; Toast toast = Toast.makeText(this, R.string.ringtone_default_message, Toast.LENGTH_SHORT); toast.setGravity(Gravity.CENTER, 0, 0); toast.show(); &#125; 并且让弹出的对话框点击确定不让设置 1234567891011121314151617181920212223242526 /* * On click of Ok/Cancel buttons */ public void onClick(DialogInterface dialog, int which) &#123; boolean positiveResult = which == DialogInterface.BUTTON_POSITIVE;... else &#123; uri = mRingtoneManager.getCustomeRingtoneUri(getRingtoneManagerPosition(mClickedPos)); &#125; //begin add ************** if (mClickedPos != -1 &amp;&amp; mCanPlay &amp;&amp; uri != null) &#123; resultIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI, uri); setResult(RESULT_OK, resultIntent); &#125; else &#123; Toast toast = Toast.makeText(this, R.string.ringtone_default_message,Toast.LENGTH_SHORT); toast.show(); setResult(RESULT_CANCELED); &#125; //end add ************** &#125; else &#123; setResult(RESULT_CANCELED); &#125; [QUESTION] [时钟]通话中倒计时铃声的声音不停止 [SOLUTION] \packages\apps\DeskClock\src\com\android\deskclock\AsyncRingtonePlayer.java //modified************** mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_ALARM, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); mRingtone.play(); return scheduleVolumeAdjustment; } /** * Sets the volume of the ringtone. * * @param volume a raw scalar in range 0.0 to 1.0, where 0.0 mutes this player, and 1.0 * corresponds to no attenuation being applied. */ private void setRingtoneVolume(float volume) { try { mSetVolumeMethod.invoke(mRingtone, volume); } catch (Exception e) { LogUtils.e(TAG, &quot;Unable to set volume for android.media.Ringtone&quot;, e); } } /** * Stops the playback of the ringtone. Executes on the ringtone-thread. */ @Override public void stop(Context context) { checkAsyncRingtonePlayerThread(); LogUtils.i(TAG, &quot;Stop ringtone via android.media.Ringtone.&quot;); mCrescendoDuration = 0; mCrescendoStopTime = 0; if (mRingtone != null &amp;&amp; mRingtone.isPlaying()) { LogUtils.d(TAG, &quot;Ringtone.stop() invoked.&quot;); mRingtone.stop(); } mRingtone = null; if (mAudioManager != null) { //modified************** mAudioManager.abandonAudioFocus(mAudioFocusListener); } } ... //begin add ************** public OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() { public void onAudioFocusChange(int focusChange) { switch (focusChange) { case AudioManager.AUDIOFOCUS_LOSS: AsyncRingtonePlayer.this.stop(); break; } } }; } //end add ************** [QUESTION] [拨号盘]通话记录紧急呼救号码只显示紧急呼救号码不显示数字 [SOLUTION] packages/apps/Dialer / src/com/android/dialer/calllog/PhoneCallDetailsHelper.java setPhoneCallDetails（）｛ ... if (TextUtils.isEmpty(details.getPreferredName())) { //begin add ********** if (!TextUtils.isEmpty(phoneNum) &amp;&amp; PhoneNumberUtils.isEmergencyNumber(phoneNum)) { nameText = mContext.getResources().getString(R.string.emergency_call_dialog_number_for_display); } else { nameText = displayNumber; } //end add ********** // We have a real phone number as &quot;nameView&quot; so make it always LTR views.nameView.setTextDirection(View.TEXT_DIRECTION_LTR); ... ｝]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-编译环境初始化]]></title>
    <url>%2F2017%2F08%2F28%2FAndroid-%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Android 编译环境初始化Android源代码在编译之前，要先对编译环境进行初始化，其中最主要就是指定编译的类型和目标设备的型号。Android的编译类型主要有eng、userdebug和user三种，而支持的目标设备型号则是不确定的，它们由当前的源码配置情况所决定。 首先第一步就是加载envsetup.sh脚本，执行路径source build/envsetup.sh 打开envsetup.sh，第一个就是函数function hmm() function hmm() { cat &lt;&lt;EOF Invoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment: - lunch: lunch &lt;product_name&gt;-&lt;build_variant&gt; - tapas: tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips|armv5|arm64|x86_64|mips64] [eng|userdebug|user] - croot: Changes directory to the top of the tree. - m: Makes from the top of the tree. - mm: Builds all of the modules in the current directory, but not their dependencies. - mmm: Builds all of the modules in the supplied directories, but not their dependencies. To limit the modules being built use the syntax: mmm dir/:target1,target2. - mma: Builds all of the modules in the current directory, and their dependencies. - mmma: Builds all of the modules in the supplied directories, and their dependencies. - provision: Flash device with all required partitions. Options will be passed on to fastboot. - cgrep: Greps on all local C/C++ files. - ggrep: Greps on all local Gradle files. - jgrep: Greps on all local Java files. - resgrep: Greps on all local res/*.xml files. - mangrep: Greps on all local AndroidManifest.xml files. - mgrep: Greps on all local Makefiles files. - sepgrep: Greps on all local sepolicy files. - sgrep: Greps on all local source files. - godir: Go to the directory containing a file. Environment options: - SANITIZE_HOST: Set to &apos;true&apos; to use ASAN for all host modules. Note that ASAN_OPTIONS=detect_leaks=0 will be set by default until the build is leak-check clean. Look at the source to view more functions. The complete list is: EOF # 查找编译环境根目录 T=$(gettop) local A A=&quot;&quot; for i in `cat $T/build/envsetup.sh | sed -n &quot;/^[[:blank:]]*function /s/function \([a-z_]*\).*/\1/p&quot; | sort | uniq`; do A=&quot;$A $i&quot; done echo $A } 执行hmm()，这方法就是打印两个EOF之间内容，提示可以执行的命令，命令有什么作用，还有列出所有函数的列表，for循环就是，读取build/envsetup.sh文件，并通过sed操作获取其中定义的函数，并进行排序输出，存放到变量$A中。 其中gettop函数从指定的$TOP目录或当前目录开始查找build/core/envsetup.mk文件，并将能找到该文件的目录返回给调用函数作为操作的根目录 function gettop { local TOPFILE=build/core/envsetup.mk # 如果编译环境已经设置了$TOP，就检查$TOP/build/core/envsetup.mk文件是否存在 if [ -n &quot;$TOP&quot; -a -f &quot;$TOP/$TOPFILE&quot; ] ; then # The following circumlocution ensures we remove symlinks from TOP. # 转到$TOP目录，通过命令`/bin/pwd`将$TOP目录指向的真实路径存放到PWD中 (cd $TOP; PWD= /bin/pwd) else # 如果当前路径下能够找到build/core/envsetup.mk文件， # 则将当前目录的真实路径存放到PWD中 if [ -f $TOPFILE ] ; then # The following circumlocution (repeated below as well) ensures # that we record the true directory name and not one that is # faked up with symlink names. PWD= /bin/pwd else # 如果当前目录下无法找到build/core/envsetup.mk文件， # 则不断返回到外层目录查找，直到到达根目录/为止 # 保存查找操作前的路径 local HERE=$PWD T= while [ \( ! \( -f $TOPFILE \) \) -a \( $PWD != &quot;/&quot; \) ]; do # 转到外层目录 \cd .. # 将当前路径保存到T中 T=`PWD= /bin/pwd -P` done # 查找完后恢复操作前的路径 \cd $HERE # 如果目录T包含build/core/envsetup.mk，说明是T是编译的根目录 if [ -f &quot;$T/$TOPFILE&quot; ]; then # 输出$T中保存的路径作为gettop的返回值 echo $T fi fi fi } source build/envsetup.sh之后就是lunch，lunch操作根据传入参数选项设置TARGET_PRODUCT, TARGET_BUILD_VARIANT和TARGET_BUILD_TYPE function lunch() { local answer # 获取lunch操作的参数 if [ &quot;$1&quot; ] ; then answer=$1 else # lunch操作不带参数，则先显示lunch menu，然后读取用户输入 print_lunch_menu echo -n &quot;Which would you like? [aosp_arm-eng] &quot; read answer fi local selection= # lunch操作得到的结果为空（例如用户直接在lunch要求输入时回车的情况） # 则将选项默认为&quot;aosp_arm-eng&quot; if [ -z &quot;$answer&quot; ] then selection=aosp_arm-eng # lunch操作得到的输入是数字，则将数字转换为LUNCH_MENU_CHOICES中的字符串 elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;) then if [ $answer -le ${#LUNCH_MENU_CHOICES[@]} ] then selection=${LUNCH_MENU_CHOICES[$(($answer-1))]} fi # lunch操作得到的是字符串，直接将字符串保存到selection中 elif (echo -n $answer | grep -q -e &quot;^[^\-][^\-]*-[^\-][^\-]*$&quot;) then selection=$answer fi # 检查selection的值是否正常 # 例如选择了一个LUNCH_MENU_CHOICES中不存在的索引，则selection就为空 if [ -z &quot;$selection&quot; ] then echo echo &quot;Invalid lunch combo: $answer&quot; return 1 fi export TARGET_BUILD_APPS= # # 分离selection字符串，例如：aosp_fugu-userdebug # # 获取第一个&apos;-&apos;后的部分，这里即userdebug，保存到variant local variant=$(echo -n $selection | sed -e &quot;s/^[^\-]*-//&quot;) # 检查variant是否合法，即是否选项(user, userdebug, eng)之一，如果不是，输出提示 check_variant $variant if [ $? -ne 0 ] then echo echo &quot;** Invalid variant: &apos;$variant&apos;&quot; echo &quot;** Must be one of ${VARIANT_CHOICES[@]}&quot; variant= fi # 获取最后一个&apos;-&apos;前的部分，这里即aosp_fugu，保存到product local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;) # 设置TARGET_PRODUCT和TARGET_BUILD_VARIANT TARGET_PRODUCT=$product \ TARGET_BUILD_VARIANT=$variant \ # 根据前面的设置，更新编译环境相关变量 build_build_var_cache if [ $? -ne 0 ] then echo echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot; echo &quot;** Do you have the right repo manifest?&quot; product= fi # product或variant为空的情况下，退出函数 if [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ] then echo return 1 fi # export 编译选项TARGET_PRODUCT, TARGET_BUILD_VARIANT和TARGET_BUILD_TYPE三元组 export TARGET_PRODUCT=$product export TARGET_BUILD_VARIANT=$variant export TARGET_BUILD_TYPE=release echo # 设置其他环境变量，如PROMPT_COMMAND，编译toolchain和tools相关的路径等 set_stuff_for_environment # 输出当前的设置选项 printconfig # 清空环境变量 destroy_build_var_cache } 第三步choosevariant，读取用户输入设置TARGET_BUILD_VARIANT为user,userdebug或eng function choosevariant() { echo &quot;Variant choices are:&quot; local index=1 local v # 从1开始，循环显示VARIANT_CHOICES数组的内容，效果如下： # $ choosevariant # Variant choices are: # 1. user # 2. userdebug # 3. eng # Which would you like? [eng] # for v in ${VARIANT_CHOICES[@]} do # The product name is the name of the directory containing # the makefile we found, above. echo &quot; $index. $v&quot; index=$(($index+1)) done local default_value=eng local ANSWER export TARGET_BUILD_VARIANT= # 交互读取TARGET_BUILD_VARIANT设置 while [ -z &quot;$TARGET_BUILD_VARIANT&quot; ] do # 读取用户输入，默认为[eng] echo -n &quot;Which would you like? [$default_value] &quot; if [ -z &quot;$1&quot; ] ; then read ANSWER else # 如果choosevariant有带参数，则直接用保存参数 echo $1 ANSWER=$1 fi # 如果 ANSWER 长度为0，即用户直接回车输入的情况 if [ -z &quot;$ANSWER&quot; ] ; then export TARGET_BUILD_VARIANT=$default_value # 将ANSWER的数值转换为VARIANT_CHOICES数组中的字符串 elif (echo -n $ANSWER | grep -q -e &quot;^[0-9][0-9]*$&quot;) ; then if [ &quot;$ANSWER&quot; -le &quot;${#VARIANT_CHOICES[@]}&quot; ] ; then export TARGET_BUILD_VARIANT=${VARIANT_CHOICES[$(($ANSWER-1))]} fi else # 调用check_variant是否为有效值 if check_variant $ANSWER then export TARGET_BUILD_VARIANT=$ANSWER else echo &quot;** Not a valid variant: $ANSWER&quot; fi fi # 如果choosevariant带了参数，则不再读取输入，跳出循环 if [ -n &quot;$1&quot; ] ; then break fi done } 编译环境初始化后完成了以下三点： 1. 将vendor和device目录下的vendorsetup.sh文件加载到了当前终端； 2. 新增了lunch、m、mm和mmm等命令； 3. 通过执行lunch命令设置好了TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_BUILD_TYPE和TARGET_BUILD_APPS等环境变量。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-CTS认证测试]]></title>
    <url>%2F2017%2F08%2F22%2FAndroid-CTS%E8%AE%A4%E8%AF%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Android-CTS认证测试一、什么是CTSGoogle GSM 认证测试组成 CTS 为 Compatibility Test Suite（兼容性测试） CTS的目的就是让各种Android（如手机）开发商能够开发出兼容性更好的Android设备。 GTS为 GMS Test Suite（GMS测试用例包） GTS的目的是让各种Android设备上的原生Google GSM 应用能稳定的运行和使用。 ctsVerifier 即ctsVerifier.apk(包含其配套测试资源)，补充CTS测试，安装到Android 设备上逐条手动测试，有些测试需要用到外设（如USB Microphone和Audio）配合测试。 二、获取CTS/GTS/ctsVerifier测试资源1、CTS官方下载地址 (翻墙网络环境)：http://source.android.com/compatibility/downloads.html 下载对应Android 7.0 版本下的最新arm架构的CTS测试包， 展讯9861平台使用x86架构的CTS测试包。 2、GTS客户需要和google签约，获取License，取得widevine专利代码，集成到Android版本，预置GMS包，用获取GTS测试包测试， 7.0 widevine，由Google 或者其第三方机构提供 ，平台不发布， 合入路径：/system/vendor/lib/mediadrm/libwvdrmengine.so 3、CtsVerifier官方下载地址 (翻墙网络环境)：http://source.android.com/compatibility/downloads.html 下载对应Android 7.0 版本下的最新arm架构的ctsVerifier测试包， 展讯9861平台使用x86架构的ctsVerifier测试包， CTS media文件获取路径地址和CTS/ctsVerifier一样，但是 7.0 需要选择 android-cts-media-1.2.zip 测试前确认需要测试的CTS包版本， CTS和CTS Verifier对应。 三、配置CTS环境测试包 CTS测试工具的压缩文件，前Android 7.0最新CTS测试包为 android-cts-7.0_r10-linux_x86-arm.zip GTS测试工具的压缩包最新为（GTS测试包不区分Android系统） android –gts-4.1 r2.zip 需要解压，在该文件路径下输入：unzip xxxxx.zip即可解压。 四、CTS测试前设备设置测试版本要求为user版本 语言设置为English(United States) 需要和软件工程师确认版本为user版本 开启“USB调试“ Settings &gt; Language &amp; input &gt; language，设为English(United States) 选择Android keyboard输入法 settings &gt; Language &amp; input &gt; Default &gt; Android keyboard，勾选 保持唤醒状态 状态栏下拉 &gt; USB debugging connected &gt; Developer options &gt; USB debugging，勾选 设置屏幕超时为最长时间30分钟 Settings &gt; Display &gt; Sleep &gt; 30 minutes，勾选 设置永不锁屏 Settings &gt; Security &gt; Screen lock &gt; none，勾选 连接可用wifi（翻墙的AP） 最好是支持IPV6的翻墙wifi 开启蓝牙 Settings &gt; Bluetooth ，打开 拷贝媒体文件 Ubuntu上运行android-cts-media-1.2文件copy_media.sh脚本或者手动将bbb_short、bbb_full到sd卡test文件中 SIM卡本机号码设置 需要将卡号写道对应的SIM卡上，并到设置中查看：设置-&gt;关于手机-&gt;状态消息， 开启Location Settings &gt; Location &gt; On（6.0以上版本每次执行前均会检查GPS是否开启，未开启则停止测试）]]></content>
      <categories>
        <category>Android CTS</category>
      </categories>
      <tags>
        <tag>Android CTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-OTA差分包升级失败]]></title>
    <url>%2F2017%2F08%2F10%2FAndroid-OTA%E5%B7%AE%E5%88%86%E5%8C%85%E5%8D%87%E7%BA%A7%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[Android-解决OTA差分包升级失败每次编译版本make之后都要执行make otapackage命令，make otapackage就是生成ota包的，一个完整包，一个中间包。每次编译完版本后都要保存这两个包，否则就不能做OTA升级。今天./build/tools/releasetools/ota_from_target_files –block -i -v old_target.zip new_target.zip update.zip生成的差分包发现不能升级。从之前编完版本保留下来的build.prop和今天保留的build.prop发现里面的recovery_id不一样，说明make之后没有再执行make otapackage，而发去出的版本正是这个没有make otapackage的版本，那完蛋了，这下怎么办了，用户买了手机今后不能升级了。 差分包大致是根据新老版本中间包去做差异对比的，./build/tools/releasetools/ota_from_target_files –block -i -v old_target.zip new_target.zip update.zip此命令如果不添加 –block 参数，意思是拿out/…/system目录下的…/app/，…/priv-app/来做对比，如果加了–block参数，则是用out/…/system.img做差异。 目前情况是,发出的版本是v1.0版本，然后在此版本上make之后没有make otapackage，保留的是make后的整包和差分包，相当于保留的包是v1.1的版本，而今天出的才是v1.1版本的。 解决方法121,用发出去的版本的system.img替换没有make otapackage的中间包的system.img2,用发出去的版本的out/.../system目录下的.../app/，.../priv-app/的APK替换没有make otapackage的中间包APK 但是目前添加–block很不稳定，很有可能不能生成差分包。那尝试替换APK的方法，首先根据差分包升级报错的APK用adb pull system/app/xxx.apk D:/out 发出版本的APK从手机pull出来， 一个一个替换没有make otapackage的中间包的APK。 然而中途发现，user版本有些文件是没有权限提取出来的！这可如何是好！ 就展讯平台来说，每个版本都打包一个.PAC包,此包里面包含各种.img的文件。 那可以尝试解包PAC,从中提取system.img，因为此包包含system各种APK等等文件。解包PAC可以用展讯刷机工具加载PAC包,在安装目录bin下可以找到加载的包,从中可以提取system.img 那问题来了system.img又如何解包呢？ ROM大师，玩机达人解包神器，加载system.img后点击配置文件，里面就是所有的system目下的东西,用对比工具对比system目录和中间包的system目录的差异，直接替换。（中间包为.zip格式文件，不要解压,用360压缩工具打开直接替换，因为解压中间包再重新打包生成不了差分包，不知道中间包的打包格式） 最后./build/tools/releasetools/ota_from_target_files -i -v old_target.zip new_target.zip update.zip 不要–block成功生成差分包。验证成功！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-姓名过长的联系人无法复制到SIM]]></title>
    <url>%2F2017%2F06%2F02%2FAndroid-%E5%A7%93%E5%90%8D%E8%BF%87%E9%95%BF%E7%9A%84%E8%81%94%E7%B3%BB%E4%BA%BA%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E5%88%B0SIM%2F</url>
    <content type="text"><![CDATA[Android-姓名过长的联系人无法复制到SIMSIM卡联系人姓名字段的长度是有限制的，这跟SIM卡的设据原理有关（根据SIM卡设计原理，能存储在SIM卡的单个联系人长度为28个字符，14个字符用于存储号码，另外14个字符用于存储联系人姓名），若为汉字，最多11个，若为英文字母，最多14个，是无法进行修改的。 http://blog.csdn.net/wds1181977/article/details/40620141 如果对名字字符串截取,是否考虑名字保存不完全的情况,从用户角度来看，也属于BUG，对名字截取个人觉得没有必要，人都是外号的，小明小红什么的，就算是英文也不会写全名，毕竟sim卡已经有限定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 预置APK]]></title>
    <url>%2F2017%2F05%2F17%2FAndroid-%E9%A2%84%E7%BD%AEAPK%2F</url>
    <content type="text"><![CDATA[Android 预置APK一、预置APK的三种方式第一种：/system/app 预置在该目录下的APK，用户不能卸载 第二种：/data/app 应用是可以卸载 第三种：/system/preloadapp 应用用户可以卸载，但是恢复出厂设置时可以还原 二、如何预置无源码APK使得用户可以卸载1、将apk拷贝到vendor/sprd/partner/prebuilt_apps/下 2、在vendor/sprd/partner/prebuilt_apps/目录下添加mk文件，在mk文件中添加apk的定义，apk按照下面的例子添加（此处以Test.apk为例） include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := Test LOCAL_MODULE_CLASS := APPS LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)（最终apk所放的目录） LOCAL_SRC_FILES := Test.apk include $(BUILD_PREBUILT) 三、如何预置有源码APK使得用户可以卸载1、在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以 预制一个名为Test的APK为例 2、将 Test.apk 放到 packages/apps/Test 下面； 3、在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := Test LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := $(call all-java-files-under, src) LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) include $(BUILD_PACKAGE) include $(call all-makefiles-under,$(LOCAL_PATH)) 4、修改/vendor/sprd/open-source/common_packages.mk 将 Test 添加到 PRODUCT_PACKAGES 里面。 四、如何将APK 预置到system/priv-app里？加入priv-app方法:在Android.mk中增加 LOCAL_PRIVILEGED_MODULE := true 五、如何预置APK使得用户可以卸载？有两种方法： 方法一： 在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以 预制一个名为Test的APK为例 将 Test.apk 放到 packages/apps/Test 下面； 在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # Module name should match apk name to be installed LOCAL_MODULE := Test LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := $(LOCAL_MODULE).apk LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_CERTIFICATE := PRESIGNED LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) include $(BUILD_PREBUILT) 这个比不能卸载的多了一句 LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS) 方法二： 将需要预置的 apk 拷贝到： vendor/mediatek/${Project}/artifacts/out/target/product/${Project}/data/app/ 重新 build 整个工程 如果没有相应目录则需手动创建。 六、如何使得用户在将预置的 APK 卸载后，恢复出厂设置时能恢复？为了让用户在将预置的 APK 卸载后，恢复出厂设置时能恢复， 做法是： 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/system目录下新建一个名为appbackup的文件夹，将该应用的apk文件copy到appbackup文件夹下 在mediatek/config/project_name/ProjectConfig.mk文件中添加定义：MTK_SPECIAL_FACTORY_RESET=yes 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/data/app下创建一个.restore_list，并且在其中添加语句： /system/appbackup/xxx.apk（注意，.restore_list中的每一行都要以&quot;/system” 开头） 当卸载了data/app下的apk后，再恢复出厂设置，系统会从 .restore_list 中读取apk的名字，然后从 appbackup 文件中把apk重新拷贝到data/app下，从而恢复data/app下已经卸载了的apk。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Camera SnapDrogonCamera预览大小和照片大小]]></title>
    <url>%2F2017%2F04%2F10%2FAndroid-Camera-SnapDrogonCamera%E9%A2%84%E8%A7%88%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%85%A7%E7%89%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[Android Camera SnxxDrogxxCamera预览大小和照片大小预览大小和照片大小是在CameraSettings， 初始化相机预览大小 1234567891011121314151617181920212223242526272829303132333435 // 初始化相机预览大小public static void initialCameraPreviewSize(Context context, Parameters parameters) &#123; // When launching the camera app first time, we will set the picture // size to the first one in the list defined in "arrays.xml" and is also // supported by the driver. // 当第一次启动相机应用程序时，我们将将预览图片大小设置为“xml”中定义的列表中的第一个，并由驱动程序支持。 String previewSize = ComboPreferences.get(context).getString( CameraSettings.KEY_PREVIEW_SIZE, null); // 第一次设预览大小为"1920x1080" if (previewSize == null) &#123; previewSize = "1920x1080"; SharedPreferences.Editor editor = ComboPreferences.get(context) .edit(); editor.putString(KEY_PREVIEW_SIZE, previewSize); editor.apply(); &#125; // 获得可支持的预览大小 List&lt;Size&gt; supported = parameters.getSupportedPreviewSizes(); if (supported == null) return; // 获取可支持列表 // for (String candidate : context.getResources().getStringArray( // R.array.pref_camera_previewsize_entryvalues)) &#123; // 匹配支持列表，设置为列表第一个 if (setCameraPreviewSize(previewSize, supported, parameters)) &#123; // SharedPreferences.Editor editor = ComboPreferences // .get(context).edit(); // editor.putString(KEY_PREVIEW_SIZE, candidate); // editor.apply(); return; &#125; // &#125; Log.e(TAG, "No supported preview size found");&#125; 这里强制设置第一次进入到相机的预览界面为1920x1080，但如果设备不支持的话是按array定义的第一个，其中List supported = parameters.getSupportedPreviewSizes();可以获得设备支持的预览大小，而context.getResources().getStringArray(R.array.pref_camera_previewsize_entryvalues) 可以获得array定义的预览大小列表，这是有区别的。 初始化拍照后图片的大小 123456789101112131415161718192021// 初始化拍照后图片的大小public static void initialCameraPictureSize(Context context, Parameters parameters) &#123; // When launching the camera app first time, we will set the picture // size to the first one in the list defined in "arrays.xml" and is also // supported by the driver. // 当第一次启动相机应用程序时，我们将将图片大小设置为“xml”中定义的列表中的第一个，并由驱动程序支持 List&lt;Size&gt; supported = parameters.getSupportedPictureSizes(); for (String candidate : context.getResources().getStringArray( R.array.pref_camera_picturesize_entryvalues)) &#123; if (setCameraPictureSize(candidate, supported, parameters)) &#123; SharedPreferences.Editor editor = ComboPreferences.get(context) .edit(); editor.putString(KEY_PICTURE_SIZE, candidate); editor.apply(); return; &#125; &#125; Log.e(TAG, "No supported picture size found");&#125; List supported = parameters.getSupportedPictureSizes();先获取支持的图片大小，再遍历array列表，再通过setCameraPictureSize(candidate, supported, parameters)匹配设备可支持的，第一次匹配则return,达到设置array列表第一个的效果。 判断是否匹配支持列表，并且设置相机预览大小 12345678910111213141516171819202122// 判断是否匹配支持列表，并且设置相机预览大小public static boolean setCameraPreviewSize(String candidate, List&lt;Size&gt; supported, Parameters parameters) &#123; // 传入备选大小 ，获得x位置索引 int index = candidate.indexOf('x'); if (index == NOT_FOUND) return false; int width = Integer.parseInt(candidate.substring(0, index)); int height = Integer.parseInt(candidate.substring(index + 1)); // 匹配支持列表 for (Size size : supported) &#123; if (size.width == width &amp;&amp; size.height == height) &#123; //匹配则设置预览大小 parameters.setPreviewSize(width, height); return true; &#125; &#125; return false;&#125; 这个返回的是一个boolean值，这样写有一个好处，一个可以用来做判断是否可以匹配列表，再一个可以设置相机预览大小。candidate是传入的一个字符串的”1920x1080”这样的字符串。 判断是否匹配支持列表，并且设置相机预览大小 123456789101112131415//判断是否匹配支持列表，并且设置相机预览大小public static boolean setCameraPictureSize(String candidate, List&lt;Size&gt; supported, Parameters parameters) &#123; int index = candidate.indexOf('x'); if (index == NOT_FOUND) return false; int width = Integer.parseInt(candidate.substring(0, index)); int height = Integer.parseInt(candidate.substring(index + 1)); for (Size size : supported) &#123; if (size.width == width &amp;&amp; size.height == height) &#123; parameters.setPictureSize(width, height); return true; &#125; &#125; return false;]]></content>
      <categories>
        <category>Android Camera</category>
      </categories>
      <tags>
        <tag>Android Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Launcher3预置文件夹、快捷方式、桌面小部件]]></title>
    <url>%2F2017%2F04%2F02%2FAndroid-Launcher3%E9%A2%84%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%81%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E3%80%81%E6%A1%8C%E9%9D%A2%E5%B0%8F%E9%83%A8%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android Launcher3预置文件夹、快捷方式、桌面小部件一预置文件夹、快捷方式、网页桌面快捷方式123456789101112131415161718192021222324&lt;folder launcher:screen=&quot;0&quot; \\第几个页面，0是最中间的页面 launcher:x=&quot;0&quot; \\放在横向的哪个位置 launcher:y=&quot;4&quot; \\放在竖向的哪个位置 launcher:title=&quot;@string/built_in_folder_toolkit&quot;&gt; /*文件夹里面的应用图标*/ &lt;favorite launcher:packageName=&quot;com.android.calculator2&quot; //包名 launcher:className=&quot;com.android.calculator2.Calculator&quot;//类名 就是显示的Activity/&gt; &lt;favorite launcher:packageName=&quot;com.android.soundrecorder&quot; launcher:className=&quot;com.android.soundrecorder.SoundRecorder&quot; /&gt; &lt;favorite launcher:packageName=&quot;com.android.deskclock&quot; launcher:className=&quot;com.android.deskclock.DeskClock&quot; /&gt; /*网页快捷方式*/ &lt;shortcut launcher:uri=&quot;http://www.baidu.com&quot; launcher:icon=&quot;@drawable/ic_launcher_baidu&quot; //要显示的图标 launcher:title=&quot;@string/baidu_title&quot; //要显示的名字 launcher:screen=&quot;&quot; launcher:x=&quot;&quot; launcher:y=&quot;&quot; /&gt; &lt;/folder&gt; 二预置桌面小部件12345678&lt;appwidget launcher:packageName=&quot;com.android.settings&quot;launcher:className=&quot;com.android.settings.widget.SettingsAppWidgetProvider&quot; launcher:screen=&quot;3&quot; launcher:x=&quot;0&quot; launcher:y=&quot;0&quot; launcher:spanX=&quot;4&quot; //在屏幕上x方向所占的格子数 launcher:spanY=&quot;1&quot; //在屏幕上y方向所占格子数 /&gt;]]></content>
      <categories>
        <category>Android Launcher3</category>
      </categories>
      <tags>
        <tag>Android Launcher3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android N 动态壁纸列表为空？]]></title>
    <url>%2F2017%2F03%2F27%2FAndorid-AnroidN%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8%E5%88%97%E8%A1%A8%E4%B8%BA%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[Android N 动态壁纸列表为空？原因分析： google 在7.0上去掉了动态壁纸，但保留了动态壁纸的框架。 google移除该功能可能是考虑到动态壁纸功能对手机的性能功耗等影响。 解决方法： 如果没有对壁纸的特殊需求，建议保持原生设计。 如果需要添加动态壁纸，请预置相应动态壁纸app即可。 例如，可以编译Android 6.0版本的动态壁纸app： packages/wallpapers/Galaxy4 packages/wallpapers/HoloSpiral packages/wallpapers/MagicSmoke … 编译之后预置到版本中即可(与预置其他第三方apk一样)]]></content>
      <categories>
        <category>Android Launcher3</category>
      </categories>
      <tags>
        <tag>Android Launcher3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 长按Home键没有弹出最近任务页面]]></title>
    <url>%2F2017%2F03%2F24%2FAndroid-%E9%95%BF%E6%8C%89Home%E9%94%AE%E6%B2%A1%E6%9C%89%E5%BC%B9%E5%87%BA%E6%9C%80%E8%BF%91%E4%BB%BB%E5%8A%A1%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Android 长按Home键没有弹出最近任务页面5.1上默认打开最近任务的按键键值是KEYCODE_APP_SWITCH，可以采取以下两种方案 1.增加对应KEYCODE_APP_SWITCH键值的按键 2.修改frameworks/base/core/res/res/values/config.xml中 &lt;integer name=&quot;config_longPressOnHomeBehavior&quot;&gt;0&lt;/integer&gt; 0的值至1 修改此项有可能会引起CTS不过。]]></content>
      <categories>
        <category>Android Framework</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPM]]></title>
    <url>%2F2017%2F03%2F22%2FSPM%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SPM工作流程一 软件项目前期1无手机硬件设备1.1软件的立项会议（立项中包含schedule，项目配置信息，项目干系人，质量标准，风险的评估等）1.2获取平台数据 （开发工具，接口文档等）1.3安排基线负责人编译基线 并保证编译正确。1.4所有的软件研发人员熟悉基线代码。1.5获取三方接口信息；1.6确认客户接口信息；1.7确认认证相关需求。2有手机硬件设备2.1 基线稳定基线原生bug 修复 稳定基线。 2.2 项目分支建立流程2.2.1 根据软件需求来评估分支的建立方案。Case 1 理论要求所有的软件分支 是要从主基线上拉分支 Case 2 如果客户要求在原有项目的基础上 再次更新版本那么就从原有项目上 拉分支 Case 3 如果客户要求在原有项目的基础上 再次更新版本但是由于某些需求的原因例如volte功能 而原有的项目分支无法实现。如果出现这样的情况 请根据实际的项目情况 来评估分支怎么拉合适。 2.2.2 根据软件完成的时间节点评估分支的建立方案只有一个原则 根据实际的研发时间和项目的时间来评估软件分支建立方案。 2.3 需求评估流程2.3.1 拿到客户的需求文档后 请安排各课长评估具体完成的时间点2.3.2 对于简单的需求 最小的时间单位为0.5天。2.3.3 对于复杂的需求 研发的时间为3~5 工作日2.3.4 对于评估时间大于5个工作日的需求 请协调相关工程师具体研究时间节点 并说明实现的难度和困难点在那里 即风险评估。2.3.5 对于无法实现的需求 一定要给出具体的说明来阐述这个需求为什么无法完成。2.3.6 所有的需求评估完成后 必须让测试部 提交对应的bug来跟踪。2.3.7需求归档备份。2.3.8 具体参考需求评估文档。2.4 对于TP LCD Camera 的调试安排2.4.1 和项目经理协调 TP LCD Camera 资源 每一个必须要2块以上 防止器件损坏 导致无效的工作。2.4.2 安排驱动部调试 并尽量协调资源来满足工程师的要求。2.4.3 每天更新器件调试进展， block项及时发出并通知给项目经理。2.5 对于MBN QCN 的调试安排（modem调试）2.5.1 和项目经理 协调资源 安排射频工程师和modem组联调 完成需求要求的频段。2.5.2 需要送平台商安排调试验证的 ，需要协调软件 硬件 射频资源来准备样机 安排实验室调试。2.6 根据评估的结果 输出软件版本计划。2.7 安排IT 建立对应项目的BUG库2.8 协调项目经理 给出测试部的接口人。2.9 提醒项目经理 安排工具组输出对应的BT FT 工具。二 软件项目中期1需求沟通1.1需求不明确对于不明确的需求 务必让工程师具体提出不明确的点 以邮件的方式通知SPM, SPM 负责和客户的需求经理或者是接口人来确认具体的需求。需求明确后务必请接口人更新需求文档 或者SPM 要备份沟通的结果，并在相应的bug中添加comment 说明沟通的结果。 1.2需求明确1.2.1可以修改的安排工程师给出具体的完成时间点并跟踪完成情况。 1.2.2不可以修改的（理论上都可以完成 关键在于研发的时间）请工程师给出具体的风险评估文档。或者邮件说明完成的困难点 风险点。SPM 负责和需求接口人来沟通。如果无法说服客户 就延长研发的时间 让工程师有更多的时间来完成此需求，如果需求的实现对项目计划有影响需要和项目经理进行确认。 2需求类bug跟踪每天定时check bug 修改情况，对于关心的问题必要时通过邮件跟踪。 3版本号控制原则3.1 版本号命名原则：Case 1 hiapd 内部版本号命名 需要有项目组 开会讨论后决定 目前没有相关的命名文档 Case 2 客户内部版本号 需要和客户沟通确认 必须邮件沟通确认 Case 3 外部版本号 需要和客户沟通确认 必须邮件沟通确认 3.2 内部版本号递增原则：Case 1 客户认可或者归档的B01版本后 再次释放版本需要+1（B02） Case 2 客户送测后 即送国外运行商（TA 版本） 或者是国内的送测后 再次释放版本需要+1 （比如 送测版本是B11 但是后续TA 反馈问题 我们修改后再次送测就需+1 即B12版本） Case 3 关于内部版本号的变更 有的地区在送测期间 可以随时更换版本 对于这样的情况 必须在版本释放前需要和客户邮件确认是否需要修改版本号。 3.3 外部版本号递增原则：Case 1 在没有释放量产版本前 保持不变（客户特殊要求除外） Case 2 国内CTA 版本 和国外的TA 版本 理论上外部版本号不变 但是释放版本时请和客户再次确认。 Case 3 后续通过FOTA 升级的版本 需要+1 （和客户邮件确认） Case 4 MR版本（售后版本）必须+1. 3.4 备注：版本号尽量控制在10个版本之内。 4编译和释放版本4.1 编译版本：4.1.1 根据要求输出编译脚本 并上传SVN4.1.2 在10.10.1.6 建立存放版本的文件夹 说明：目前脚本中不能自动新建文件夹 必须手动在.6服务器上创建文件夹。4.1.3 软件开始研发后 如果每日比较多 每天晚上需要编译版本即daily_build 如果每日修改比较少 可以 2~3天编译版本 SPM 根据实际情况自行决定。4.2 释放版本：4.2.1 临时版本释放临时版本的释放 多数情况下是为了解决某一个或者是多个问题 响应客户的要求释放的，这样的版本可以不经过测试部的测试。就可以释放给客户，但是需要SPM 或者测试同事简单的验证而且必须保证可以正常开机。并务必在邮件中明确说明这个是临时的版本 测试部没有系统测试的字样来告知客户。 临时的版本升级要了解客户手里的机器是什么状态的机器（器件是否有差异，版本信息）确认用户可以正常升级。 4.2.2 正式版本释放Case 1 非生产版本 对于非生产版本 必须经过软件测试部的测试即提交软件测试流程 并根据测试反馈的结果 来评估是否可以释放给客户。 Case 2 试产版本 是指要在产线上用于试产的版本 试产前提醒项目经理组织每次试产前做change list 评审（在试产回来每次验证中有可能需要软件配合修改的地方 这类版本必须经过软件测试部，硬件测试部，工作组的测试 并提交相应的测试流程，测试完成后评估是否可以用于生产 如果可以并上传DCC 系统下发工厂。 Case 3 量产版本 是在客户接受软件可以用于生产 量产前 请和项目经理确认是否有物料的变更 如果存在物料变更 需要软件调整并压力测试。还有需要明确量产软件的烧写方式。 这类软件必须 保证 CTS GTS 测试通过 （国内外通用）必须经过软件测试部，硬件测试部，工作组的测试 并提交相应的测试流程，测试完成后评估是否可以用于生产，如果可以并上传DCC系统下发工厂。 5安排测试部测试5.1 需求测试Case 1 在正式的B01版本发布前，即每天编译的版本进行测试。 Case 2 正式的B01版本 验证 Case 3 如果需要在B02 版本也请安排测试 5.2 bug 回归正式运行OA 流程提交的测试版本均需要安排此项测试。 5.3 CTS GTS 测试Case 1 在提交客户版本前 必须安排测试一次 即摸底的测试 Case 2 正式外发给客户的版本 必须安排测试。 Case 3 基线有重大升级后安排测试 Case 4 google 要求调整测试包 即CTS GTS 测试脚本变更 必须安排测试。 5.4 monkey 测试：Case 1 正式B01 安排测试。 Case 2 软件中集成比较多的三方apk 后请安排测试。 Case 3 版本有重大修改 比如基线调整 安排测试。 Case 4 送测的版本（TA版本） 请安排测试 5.5 FOTA 测试：正式外发的版本 均要求测试。 5.6 系统测试（系统全用例）正式外发的版本 均要求测试。 5.7 续航测试Case 1 量产前的软件版本 必须安排一次测试 Case 2 软件基线调整 安排测试 Case 3 添加大量三方apk 后 请安排测试。 5.8 待机电流测试正式的外发版本必须安排测试 5.9 信令连接测试正式的外发版本必须安排测试 5.10 射频测试量产前的版本 必须安排一次测试。 5.11 工具组测试正式的外发版本必须安排测试 5.12 场测场测前需要软件项目经理将启动场测的邮件发给项目相关成员，测试工程师将抓log的方法发出，让研发工程师进行确认。 6 UE 版本如果有UE 版本需求 请安排释放UE 版本 UE 释放要求 Case 1 基线基本稳定 没有重点的问题存在 Case 2 UE需求明确 7 CTA 版本如果有CTA版本需求 请安排释放CTA版本 7.1 CTA 版本需求合入已知CTA问题，解决前期个别问题 7.2 CTA 准备工作Case 1 测试用例确认 Case 2 确认资料 准备样机和配件 8外发客户B01版本(首个版本)8.1 根据软件版本计划 在计划时间点提交客户B01版本8.2 在提交B01 版本时 必须保证所有的需求修改完成 如果还存在需求未完成的 请SPM 和客户沟通来确认是否B01版本.8.3 必须安排相关的测试 ，并取得测试报告后 有项目组来评估是否可以释放给客户。9处理客户反馈的问题9.1 国内反馈9.1.1 客户测试team 反馈：Case 1 安排hiapd测试部 同步客户反馈问题提交到我们BUG库 Case 2 跟踪反馈问题 对bug 描述不明确的请协助工程师沟通。 9.1.2 客户邮件反馈：接到反馈邮件后 请安排测试部的同事复现 如果可以复现请安排测试部提交bug。如果无法复现的问题 请spm和客户沟通确认问题。 9.2 国外反馈国外的反馈 一般都是在国内无法测试的问题。SPM务必整理备份。问题主要集 中在 协议组和modem组 9.2.1 协议组问题：务必请客户提供adb log ，qxdm log，视频或者是截图并提供对比机的测 试情况 对于短彩信问题请客户提供短信数据库文件，对比机apn 参数。 9.2.2 modem组问题：务必请客户提供adb log ，qxdm log，视频或者是截图 和qcn文件。对比 机的测试情况。 10外发TA 版本：10.1 时间点：取决于软件版本计划。如果客户不认可版本计划，必须和项目经理沟通后 再和 客户讨论并邮件确认时间点。 10.2 处理TA 反馈问题：10.2.1 问题反馈：请客户提交相关的资源 即log 视频等 安排测试部复现 并提交bug 安排工程师分析。 10.2.2 新增需求：参考需求评估流程来确认时间点 并和项目经理确认是否需要完成。Spm 没有权利答复客户。 三 软件项目后期1了解客户测试流程1.1中兴客户：通过的标准应该是5A 40B，除此之外，A类Bug,如果分值高的话，是一票否决的，出现这种分值高的bug,要格外注意，尽快处理。模拟用户的标准应该是B类不超过12%，非问题bug及不重要的bug,尽早沟通关闭或降级。 1.2联想客户：1.3中国移动：2 bug 评审机制：在项目量产前 需要项目组相关人员和研发课长 来评估所有bug 的风险，确定修改的方案。修改的时间点等信息。对于不做修改的问题统一降级为4级。 3外发量产版本：3.1前提条件：Case 1 客户必须TA 或者是明确邮件确认软件可以量产。 Case 2 现有存在的bug 符合客户的量产标准。 Case 3 工程模式中没有严重的问题。 Case 4 CTS GTS 测试没有fail项。 3.2测试安排：务必启动量产软件外发流程。 3.3主要事项：Case 1 注意客户拿到量产软件的时间点。 Case 2 CTS GTS 测试。 Case 3 工具组测试。 Case 4 FOTA 版本必须生成和验证。 4书写项目总结项目量产后 请务必输出项目总结。 四 软件项目维护是指项目已经量产，主要是由于售后问题客户要求我们更新软件。对于这些软件我们称MR 版本。 MR 版本生成要做到最小的修改。即将风险降到最低。 MR 版本生成原则 1.1只安排修改客户反馈的问题。1.2对于一些必要的功能 进行升级例如AFW 功能和 CTS GTS 的问题。1.3FOTA 版本必须验证 （例如 量产软件是B12，售后反馈问题我们出B13 那么FOTA 必须验证 B12 B13,B13B14 2个版本）1.4MR 版本的测试也要符合量产软件测试标准。五 沟通的注意事项1一定要第一时间响应客户提出的各种问题。2对于一些问题的沟通 如果有工程师介入 尽量发给相关的人员不要全部回复。3对于客户要求确认时间点的邮件 务必需要和项目经理沟通后再回复。4对于一些需求功能的确认 一定要和相关的工程师沟通后再回复。六 软件需求评估项目各阶段客户需求评估策略 序号 项目阶段 客户需求评估策略 备注 1 立项前 尽量满足客户需求，根据实际评估情况给出风险预估，资源需求，进度安排。对于不能实现或部分实现的需求要提交客户确认。 SPM要全面收集客户需求，避免遗漏 2 立项EVT 满足客户合理需求，根据实际评估情况给出风险预估，资源需求，进度安排。 SPM作需求变更记录 3 EVT DVT 满足客户合理的小型需求，对于工作量和难度较大的需求，需要在进度评估和风险评估的基础上与客户沟通。 SPM作需求变更记录 4 DVT PVT 通常不再接收新的客户需求。特殊情况需要客户对进度做出让步，风险共担。 SPM作需求变更记录 5 PVT MP 不再接收新的客户需求。客户强烈要求的，给出风险评估和进度评估，在此基础上要求客户风险共担。 SPM作需求变更记录 6 MP 不再接收新的客户需求。客户如有要求，根据工作量评估进度，并且要提报PM成本增加。新需求不影响原有量产进度情况下作为后续维护升级需求开发。 SPM作需求变更记录 6.3运营商软件需求评估流程 6.3.1运营商的需求由公司产品认证部及时更新到SPM 6.3.2 SPM根据运营商需求的时效和产品类别，确认本项目是否需要导入评估 6.3.3对于需要导入的运营商需求直接启动开发流程 6.4公司内软件需求评估流程 6.4.1公司内的软件需求是由公司内其他部门提出，给到SPM 6.4.2SPM启动软件需求评估流程 6.4.3SPM根据实际评估结果决定是否在项目中实施 6.4.4若SPM判定不实施该需求，需与提出需求部门沟通说明原因 6.4.5如有分歧意见，双方给出各自理由，由PM决断。]]></content>
      <categories>
        <category>SPM</category>
      </categories>
      <tags>
        <tag>SPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 修改默认亮度太暗]]></title>
    <url>%2F2017%2F03%2F20%2FAndroid-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E4%BA%AE%E5%BA%A6%E5%A4%AA%E6%9A%97%2F</url>
    <content type="text"><![CDATA[Android 修改默认亮度太暗修改屏幕默认亮度frameworks\base\packages\SettingsProvider\res\values\defaults.xml &lt;integer name=&quot;def_screen_brightness&quot;&gt;102&lt;/integer&gt; 这个值的取值范围为0~255，按照实际需求修改”def_screen_brightness”的值。 很多项目会在/device/对应平台/对应工程/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml overlay 这个xml文件，所以会导致只修改frameworks中的值并不会起作用。因此，需要优先检查是否存在overlay的情况。 修改最小,最大亮度值，以及开机启动的默认亮度值最小值，不得小于0： &lt;integer name=&quot;config_screenBrightnessSettingMinimum&quot;&gt;30&lt;/integer&gt; 最大值，建议不大于255： &lt;integer name=&quot;config_screenBrightnessSettingMaximum&quot;&gt;255&lt;/integer&gt; 默认值，介于最大值及最小值中间： &lt;integer name=&quot;config_screenBrightnessSettingDefault&quot;&gt;100&lt;/integer&gt;]]></content>
      <categories>
        <category>Android Framework</category>
      </categories>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb命令]]></title>
    <url>%2F2017%2F02%2F26%2Fadb%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[adb命令Android adb你真的会用吗?http://www.jianshu.com/p/5980c8c282ef adb基本命令https://my.oschina.net/atearsan/blog/342954 Awesome Adb——一份超全超详细的 ADB 用法大全https://github.com/mzlogin/awesome-adb ADB用法大全http://www.tuicool.com/articles/2MFJri6]]></content>
      <categories>
        <category>adb命令</category>
      </categories>
      <tags>
        <tag>adb命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN命令]]></title>
    <url>%2F2017%2F02%2F25%2FSVN%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[SVN命令1、 将文件checkout到本地目录 svn checkout path（path是服务器上的目录） 例如：svn checkout svn: // 192.168 . 1.1 / pro / domain 简写：svn co 2、 往版本库中添加新的文件 svn add file 例如：svn add test.php(添加test.php) svn add * .php(添加当前目录下所有的php文件) 3、 将改动的文件提交到版本库 svn commit -m &quot; LogMessage &quot; [ -N ] [ --no-unlock ] PATH (如果选择了保持锁，就使用--no-unlock开关) 例如：svn commit -m &quot; add test file for my test &quot; test.php 简写：svn ci 4、 加锁/解锁 svn lock -m &quot; LockMessage &quot; [ --force ] PATH 例如：svn lock -m &quot; lock test file &quot; test.php svn unlock PATH 5、 更新到某个版本 svn update -r m path 例如： svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved ，最后再提交commit) 简写：svn up 6、 查看文件或者目录状态 1 ）svn status path （目录下的文件和子目录的状态，正常状态不显示） 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 2 ）svn status -v path (显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 简写：svn st 7、 删除文件 svn delete path -m &quot; delete test fle &quot; 例如：svn delete svn:// 192.168.1.1 /pro/domain/test.php -m &quot; delete test file &quot; 或者直接svn delete test.php 然后再svn ci -m &apos;delete test file‘，推荐使用这种 简写：svn (del, remove, rm) 8、 查看日志 svn log path 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 9、 查看文件详细信息 svn info path 例如：svn info test.php 10、 比较差异 svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php 简写：svn di 11、 将两个版本之间的差异合并到当前文件 svn merge -r m:n path 例如：svn merge -r 200 : 205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 12、 SVN 帮助 svn help svn help ci 以上是常用命令，下面写几个不经常用的13、 版本库下的文件和目录列表 svn list path 显示path目录下的所有属于版本库的文件和目录 简写：svn ls 14、 创建纳入版本控制下的新目录 svn mkdir : 创建纳入版本控制下的新目录。 用法: 1、mkdir PATH... 2、mkdir URL... 创建版本控制的目录。 1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增 调度，以待下一次的提交。 2、每个以URL指定的目录，都会透过立即提交于仓库中创建。 在这两个情况下，所有的中间目录都必须事先存在。 15、 恢复本地修改 svn revert : 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 用法: revert PATH... 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复 被删除的目录 16、 代码库URL变 svn switch (sw): 更新工作副本至不同的URL。 用法: 1、switch URL [PATH] 2、switch --relocate FROM TO [PATH...] 1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 方法。 2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用 这个命令更新工作副本与仓库的对应关系。 17、 解决冲突 svn resolved: 移除工作副本的目录或文件的“冲突”状态。 用法: resolved PATH... 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的 相关文件，然后让 PATH 可以再次提交。 18、 输出指定文件或URL的内容。 cat 目标[@版本]...如果指定了版本，将从指定的版本开始查找。 svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)]]></content>
      <categories>
        <category>SVN命令</category>
      </categories>
      <tags>
        <tag>SVN命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser辅助功能甩动手势前进后退功能研究]]></title>
    <url>%2F2016%2F10%2F15%2FAndroid-Browser%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E7%94%A9%E5%8A%A8%E6%89%8B%E5%8A%BF%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[Android Browser 甩动手势Android Browser在设置-辅助功能里面有个甩动手势功能，有时候甩动却发现没有效果。 实现这个甩动手势的有一个类ShakeDetector，它是实现了SensorEventListener这个类。 覆盖重写了onSensorChanged（SensorEvent event）这个方法，研究这个类和这个方法，可以发现，甩动跟方向和加速度，甩动时间有关。 而出现甩动没有效果，可能还跟重力传感器有关，有些重力传感器本身就是不支持横屏的。 我研究到后来发现一个初始参数 final float SHAKE_THRESHOLD = 6.0f; 当把它调小后，甩动效果更灵敏了。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email登陆邮箱后，清除邮箱数据后，再进入邮箱，邮箱会闪退]]></title>
    <url>%2F2016%2F05%2F06%2FAndroid-Email%E7%99%BB%E9%99%86%E9%82%AE%E7%AE%B1%E5%90%8E%EF%BC%8C%E6%B8%85%E9%99%A4%E9%82%AE%E7%AE%B1%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E5%86%8D%E8%BF%9B%E5%85%A5%E9%82%AE%E7%AE%B1%EF%BC%8C%E9%82%AE%E7%AE%B1%E4%BC%9A%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[Android Email登陆邮箱后，清除邮箱数据后，再进入邮箱，邮箱会闪退After viewing the video and analyzing the logs provided for the scenario, it looks like the reported behavior is not an issue. It is the expected flow. Email app getting notified that App data and settings were cleared, which will further trigger to remove all Email accounts in the account manager and Account Manager notifying Email application back that the account has been deleted : - All these actions occur asynchronously. Hence the timing of the broadCast events plays a vital role in deciding the screen behavior when Application is relaunched. Please look into the below sequence so that you can understand the behavior better. At this point, Email account was set initially and Mailbox was displayed to the user. Now, package cleared from settings : 在观看视频并分析提供给场景的日志之后，它看起来像报告的行为不是一个问题。这是预期的流动。电子邮件应用程序收到通知，应用程序数据和设置被清除，这将进一步触发删除所有电子邮件帐户在帐户管理器和帐户管理器通知电子邮件应用程序返回帐户已被删除：-所有这些行动发生异步。因此，广播事件的时间起着至关重要的作用，在决定行为时，应用程序重新启动屏幕。请看下面的顺序，以便你能更好地理解行为。此时，电子邮件帐户已初步设置，并将邮箱显示给用户。现在，包从设置中清除： 06-22 14:15:26.626364 2108 2119 V ActivityManager: Broadcast: Intent { act=com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{48a6efa 8944:com.android.settings/1000} Clearing the package also causes Email to stop. Now, Email App is launched Please look into the below sequence so that you can understand the behavior better. At this point, Email account was set initially and Mailbox was displayed to the user. Now, package cleared from settings : 清理包裹也会导致电子邮件停止。现在，电子邮件应用程序启动请看下面的顺序，以便你能更好地理解行为。此时，电子邮件帐户已初步设置，并将邮箱显示给用户。现在，包从设置中清除： 06-22 14:15:26.626364 2108 2119 V ActivityManager: Broadcast: Intent { act=com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{48a6efa 8944:com.android.settings/1000} Clearing the package also causes Email to stop. Now, Email App is launched again by tapping the Launcher. But at this point we still did not receive settings package cleared broadcast intent that was previously sent:06-22 14:15:25.970301 2108 2907 I am_kill : [0,31972,com.android.email,1,stop com.android.email]………………………………………..06-22 14:15:28.821498 2108 2473 I am_create_task: [0,98]06-22 14:15:28.821687 2108 2473 I am_create_activity: [0,202452453,98,com.android.email/.activity.Welcome,android.intent.action.MAIN,NULL,NULL,270532608] BroadCast intent received and Accounts deletion in AccountManager is initiatedby Email App: 广播意图收到并开始删除AccountManager帐户通过电子邮件应用： 06-22 14:15:30.505155 720 881 D Email : onHandleIntent start:action = broadcast_receiver06-22 14:15:30.505900 720 881 D Email : onHandleIntent:broadcastAction = com.mediatek.intent.action.SETTINGS_PACKAGE_DATA_CLEARED06-22 14:15:30.511159 720 881 D Email : !!!onSettingsPackageClearData: send broadcastto laucher : unreadCount = 006-22 14:15:30.511644 720 881 D SettingsInterface: putStringForUser, name = com_android_email_mtk_unread, value = 0, for user : 006-22 14:15:30.943661 720 881 D Email : onHandleIntent end = broadcast_receiver Account is deleted in AccountManager and Email Application gets notified:06-22 14:15:38.968635 720 720 D Email : onReceive:action = android.accounts.LOGIN_ACCOUNTS_CHANGED 电子邮件核对账户接收广播，关闭电子邮件应用程序的学习之后，一个帐户已被删除： Email reconciles Accounts on receiving the broadCast, which shuts down Email App after learning that an account has been deleted:06-22 14:15:40.742920 720 1207 D Email : Setting compose activity to disabled06-22 14:15:40.743112 720 1207 I Email : Restarting because account deleted This scenario cannot be an always scenario, if the Email application is launched after a delay when package data is cleared.To check this please enter the Email application after a delay, say after a minute. Here acount login-screen will be visible instead of Mailbox and the Email application will not exit. This particular behavior, where Email application and services are killed when we learn that an account is deleted, is a safe way to avoid many other issues, as there could be any background action going on related to the deleted account, which may cause some serious problems. Although not as clean as it could be, killing the application is the best and the simplest thing we could do to avoid further issues with the deleted account. 如果在包数据被清除后延迟启动电子邮件应用程序，则此方案不能始终为场景。要检查这一点，请输入电子邮件应用程序后的延迟，说一分钟后。在这里，我们将看到登录屏幕而不是邮箱和邮件应用程序将不会退出。这种特殊的行为，在电子邮件应用程序和服务被杀害时，我们了解到一个帐户被删除，是一种安全的方式，以避免许多其他问题，因为可能有任何背景行动进行有关删除帐户，这可能会导致一些严重的问题。虽然没有尽可能干净，杀死应用程序是最好的，我们可以做的最简单的事情，以避免进一步的问题，已删除的帐户。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android HTMLViewer 打开.txt显示乱码]]></title>
    <url>%2F2016%2F05%2F03%2FAndroid-HTMLViewer-%E6%89%93%E5%BC%80-txt%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Android HTMLViewer 打开.txt显示乱码 具体修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317 public class HTMLViewerActivity extends Activity &#123; private static final String TAG = &quot;HTMLViewer&quot;; private WebView mWebView; private View mLoading; /// M: add auto-detector for HTML viewer private static final String ENCODING_AUTO_DETECTED = &quot;auto-detector&quot;; private static final int HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE = 1; private Intent mRCVDIntent; private String mEncodingType=&quot;&quot;; static final int MAXFILESIZE = 1024 * 1024 * 8; private void processRcvdIntent() &#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); // Javascript is purposely disabled, so that nothing can be // automatically run. s.setJavaScriptEnabled(false); /// M: add auto-detector for HTML viewer //s.setDefaultTextEncodingName(&quot;utf-8&quot;); s.setDefaultTextEncodingName(ENCODING_AUTO_DETECTED); if (mRCVDIntent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(mRCVDIntent.getStringExtra(mRCVDIntent.EXTRA_TITLE)); &#125; mWebView.loadUrl(String.valueOf(mRCVDIntent.getData())); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mRCVDIntent = getIntent(); if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; Log.d(TAG, &quot;checkSelfPermission return false&quot;); requestPermissions(new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE); return; &#125; // processRcvdIntent(); //ovvi ovviIntent(savedInstanceState); Log.d(TAG, &quot;ovvi--------------------Intent&quot;); &#125; @Override public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; Log.d(TAG, &quot;onRequestPermissionsResult&quot;); switch (requestCode) &#123; case HTMLVIEWER_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //ovvi begin ningshuran 20160718 change enter the first gibberish ovviIntent(); //end &#125; else &#123; Log.d(TAG, &quot;onRequestPermissionsResult return PERMISSION NOT GRANTED&quot;); Toast.makeText(getApplicationContext(), getResources() .getString(com.mediatek.R.string.denied_required_permission), Toast.LENGTH_LONG).show(); finish(); &#125; break; default: //do nothing &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mWebView != null) &#123; mWebView.destroy(); &#125; &#125; private class ChromeClient extends WebChromeClient &#123; @Override public void onReceivedTitle(WebView view, String title) &#123; if (!getIntent().hasExtra(Intent.EXTRA_TITLE)) &#123; HTMLViewerActivity.this.setTitle(title); &#125; &#125; &#125; private class ViewClient extends WebViewClient &#123; @Override public void onPageFinished(WebView view, String url) &#123; mLoading.setVisibility(View.GONE); &#125; @Override public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123; final Uri uri = request.getUrl(); if (ContentResolver.SCHEME_FILE.equals(uri.getScheme()) &amp;&amp; uri.getPath().endsWith(&quot;.gz&quot;)) &#123; Log.d(TAG, &quot;Trying to decompress &quot; + uri + &quot; on the fly&quot;); try &#123; final InputStream in = new GZIPInputStream( getContentResolver().openInputStream(uri)); final WebResourceResponse resp = new WebResourceResponse( getIntent().getType(), &quot;utf-8&quot;, in); resp.setStatusCodeAndReasonPhrase(200, &quot;OK&quot;); return resp; &#125; catch (IOException e) &#123; Log.w(TAG, &quot;Failed to decompress; falling back&quot;, e); &#125; &#125; return null; &#125; &#125; /* ovvi begin add */ public void ovviIntent(Bundle savedInstanceState)&#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); s.setJavaScriptEnabled(false); s.setDefaultTextEncodingName(&quot;utf-8&quot;); if (savedInstanceState != null) &#123; mEncodingType = savedInstanceState.getString(&quot;EncodingType&quot;); if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; mWebView.restoreState(savedInstanceState); &#125; else &#123; final Intent intent = getIntent(); if (intent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(intent.getStringExtra(Intent.EXTRA_TITLE)); &#125; if (intent.getData() != null) &#123; Uri uri = intent.getData(); if (intent.getType().equals(&quot;text/plain&quot;)) &#123; try &#123; mEncodingType = codeString(uri.getPath()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; &#125; if (&quot;file&quot;.equals(uri.getScheme())) &#123; File file = new File(uri.getPath()); long len = file.length(); Log.v(TAG, &quot;len = &quot; + len); if (len &gt; MAXFILESIZE) &#123; showMessage(); return; &#125; &#125; mWebView.loadUrl(uri.toString()); &#125; &#125; &#125; private String codeString(String fileName) throws Exception &#123; BufferedInputStream bin = null; int p = 0; try &#123; bin = new BufferedInputStream(new FileInputStream(fileName)); p = (bin.read() &lt;&lt; 8) + bin.read(); &#125; catch (Exception e) &#123; Log.e(TAG, &quot;IOException when get encode type&quot;, e); &#125; finally &#123; if(bin != null) bin.close(); &#125; String code = null; switch (p) &#123; case 0xefbb: code = &quot;UTF-8&quot;; break; case 0xfffe: code = &quot;Unicode&quot;; break; case 0xfeff: code = &quot;UTF-16BE&quot;; break; case 0x5c75: code = &quot;ANSI|ASCII&quot;; break; default: code = &quot;GBK&quot;; &#125; return code; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putString(&quot;EncodingType&quot;, mEncodingType); //ovvi begin ningshuran 20160712 if(mWebView!=null)&#123; Log.d(&quot;ovvi-----------------null&quot;, &quot;mWebView,is&apos;t null&quot;); mWebView.saveState(outState); &#125; //end &#125; private void showMessage() &#123; AlertDialog.Builder build = new AlertDialog.Builder(this).setTitle(R.string.app_label); build.setIcon(android.R.drawable.ic_dialog_alert); build.setMessage(R.string.file_size); build.setCancelable(true); build.setOnDismissListener(new DialogInterface.OnDismissListener()&#123; @Override public void onDismiss(DialogInterface dialog) &#123; finish(); &#125; &#125;); build.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;).show(); &#125; /* ovvi end */ /* ovvi begin ningshuran 20160718 add */ public void ovviIntent()&#123; setContentView(R.layout.main); mWebView = (WebView) findViewById(R.id.webview); mLoading = findViewById(R.id.loading); mWebView.setWebChromeClient(new ChromeClient()); mWebView.setWebViewClient(new ViewClient()); WebSettings s = mWebView.getSettings(); s.setUseWideViewPort(true); s.setSupportZoom(true); s.setBuiltInZoomControls(true); s.setDisplayZoomControls(false); s.setSavePassword(false); s.setSaveFormData(false); s.setBlockNetworkLoads(true); s.setJavaScriptEnabled(false); s.setDefaultTextEncodingName(&quot;utf-8&quot;); final Intent intent = getIntent(); if (intent.hasExtra(Intent.EXTRA_TITLE)) &#123; setTitle(intent.getStringExtra(Intent.EXTRA_TITLE)); &#125; if (intent.getData() != null) &#123; Uri uri = intent.getData(); if (intent.getType().equals(&quot;text/plain&quot;)) &#123; try &#123; mEncodingType = codeString(uri.getPath()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!mEncodingType.equals(&quot;&quot;)) &#123; mWebView.getSettings().setDefaultTextEncodingName(mEncodingType); &#125; &#125; if (&quot;file&quot;.equals(uri.getScheme())) &#123; File file = new File(uri.getPath()); long len = file.length(); Log.v(TAG, &quot;len = &quot; + len); if (len &gt; MAXFILESIZE) &#123; showMessage(); return; &#125; &#125; mWebView.loadUrl(uri.toString()); &#125; &#125;//end &#125;]]></content>
      <categories>
        <category>Android HTMLViewer</category>
      </categories>
      <tags>
        <tag>Android HTMLViewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email com.android.email.service.EmailBroadcastProcessorService模块MemLeak异常]]></title>
    <url>%2F2016%2F04%2F30%2FAndroid-Email-com-android-email-service-EmailBroadcastProcessorService%E6%A8%A1%E5%9D%97MemLeak%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Android Email com.android.email.service.EmailBroadcastProcessorService模块MemLeak异常从源码上分析，服务已经是解绑了，为什么还会报这个异常，确实很奇怪 解决结论：EmailBroadcastProcessorService是一个IntentService，在这个service中尝试绑定到EasService 并获得返回值,随后启动了一个异步线程执行后台任务，当后台任务执行完成后，会调用unbindservie。IntentService在handlerintent 执行完成后立即销毁，并检查是否有依然绑定的服务，如果有则unbind,并打印警告，由于异步线程此时尚未执行完成，因此打印出了问题描述中的LOG。实际业务流程中，并不会再次用到绑定的服务。因此这个警告不会造成实际的影响(泄露或其他问题)。建议不做修改。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Downloaded files doesnot store in SD card]]></title>
    <url>%2F2016%2F04%2F28%2FAndroid-Downloaded-files-doesnot-store-in-SD-card%2F</url>
    <content type="text"><![CDATA[Android Downloaded files doesnot store in SD card[Current status]Open Setting &gt; Storage and USB &gt; select the SD card storage. Downloaded files doesnot store in SD card.[Expected result]It should be needed to store in Sd card when selected. Google kK版本之后是不允许第三方app 写外置sdcard的，所以自然app 无法download 到sdcard上。 (在setting中的默认存储设定为SD card，为MTK扩展的功能，只能影响到内置AP，比如说内置Camera,而Chrome属于3rd party apk，他并不会去拿storageManagerEx中扩展接口获取default storage path) project 是否需要过cts？如果要过cts，就不能改，因为cts 会测这个case，cts 不允许3rd app写sdcard，不然会fail。 如果项目不需要过cts,按以下方法修改： 请找到 mediatek/config/mt6732/init.ssd.rc 和 init.ssd_nomuser.rc 和 init.no_ssd.rc ， 找到文件中的 service fuse_sdcard1 /system/bin/sdcard -u 1023 -g 1023 -w 1023 -d /mnt/media_rw/sdcard1 /storage/sdcard1class late_startdisabled 改为service fuse_sdcard1 /system/bin/sdcard -u 1023 -g 1023 -d /mnt/media_rw/sdcard1 /storage/sdcard1class late_startdisabled 将-w 1023 去掉后 new build 测试。这样会造成cts 不过，因为更改了系统的fuse管理机制。这样可以写sdcard。 说明下：由于不知道使用的config的情况，所以建议3个 init.xx.rc 都修改]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email附件丢失]]></title>
    <url>%2F2016%2F04%2F25%2FAndroid-Email%E9%99%84%E4%BB%B6%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[Android Email附件丢失问题进入qq邮箱转发有附件的邮件到163邮箱，手机端丢失附件，电脑端显示有 1，附件同名，大小不同或者附件不同名，大小不同，QQ邮箱都可以完整接收附件2，附件同名，大小不同163邮箱不能完整接收，只能显示一个，丢失一个。附件不同名，163邮箱可以完整接收。 本问题是google原生设计如此，结合问题描述分析如下：1） QQ邮箱可以完整接收相同附件 — 目前QQ邮箱默认以imap方式登陆，email端对imap类型的邮箱没有做附件去重处理，故而能全部接收2） 163邮箱不能完整接收 — 目前163邮箱默认pop3方式登陆，对与pop3类型的邮箱，email端会对附件做去重处理，通过判断其FileName，MimeType，ContentId，及Location是否相同来断定是否为相同的附件，通过判断的条件可以看出没有对附件大小进行判断，所以测试中同名而大小不一的附件不会视为同一附件，故而能全部接收 解决方案：舍去pop3的附件去重处理]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Email的简单分析]]></title>
    <url>%2F2016%2F04%2F20%2FAndroid-Email%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android Email的简单分析我看的是5.0Email的源码，看了几天AndroidEmail,不知道这些小图标是哪个类提供的 搜索了好久都没有找到，网上对Email的分析也少。最后我才发现这些小图标，包括下拉刷新等都是UnifiedEmail提供的，相当于UI就是邮件的一些界面，收件箱，抽屉实现，还有详细信息显示，编辑邮箱界面都在这里面，相当于一个jar包。还有一个Exchange里面是Email的一些服务。Email最重要的就是账户信息的处理和协议方面。Email引用Unified是通过Android.mk引用的。]]></content>
      <categories>
        <category>Android Email</category>
      </categories>
      <tags>
        <tag>Android Email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser页面字体设置过大时，字体重叠]]></title>
    <url>%2F2015%2F11%2F28%2FAndroid-Browser%E9%A1%B5%E9%9D%A2%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E8%BF%87%E5%A4%A7%E6%97%B6%EF%BC%8C%E5%AD%97%E4%BD%93%E9%87%8D%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[Android Browser 字体重叠Browser在设置-辅助功能-文子缩放和字体大小下限设置为最大时，会导致字体重叠显示不全。 原因分析：网页文字出现重叠的主要是网页排版的原因，网页CSS样式限定了行高，当宽度不够或字体较大情况下，显示区域就会重叠。由于浏览器无法对写死的的行高进行调整，所以在行高限定的网页中字体过大出现显示问题是正常的。这不是浏览器的问题。 解决方案：当需要调小字体时，在BrowserSettings.java syncStaticSettings中，可以设置默认字体大小， settings.setDefaultFontSize(16); settings.setDefaultFixedFontSize(13); 可以修改减小参数， 当需要调小字体缩放 1234567891011121314private Runnable mSetup = new Runnable() &#123;&#125; switch (getTextSize()) &#123; case SMALLEST: setTextZoom(50); break; case SMALLER: setTextZoom(75); break; case LARGER: setTextZoom(150); break; case LARGEST: setTextZoom(200); break; 其实修改了这些参数依然会出现不能修改字体缩放的作用。 12345678910//控制字体大小上下限范围private static final int MIN_FONT_SIZE_OFFSET = 5; private static final int TEXT_ZOOM_START_VAL = 10; //控制字体缩放范围 private static final int TEXT_ZOOM_STEP = 5;//控制双击缩放 private static final int DOUBLE_TAP_ZOOM_START_VAL = 5; private static final int DOUBLE_TAP_ZOOM_STEP = 5; 修改了这里的参数才会真正改变初始的值，从而达到调小缩放范围的目的。同时需要在Layout修改progressbar的值 导致这个问题真正的原因是goolge webview。从百度页面-&gt;进如美食-&gt;进入百度糯米，发现美团的页面的字体少一半。进入糗事百科。设置显示为桌面版（显示效果跟电脑打开网页效果一样），字体重叠现象。都是goolge webview导致的。这是因为4.4之后取消了字体重排 ？？]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser网络状态判断]]></title>
    <url>%2F2015%2F10%2F27%2FAndroid-Browser%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[Android Browser网络状态的判断NetworkStateHandler的构造方法里面就有网络状态的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public class NetworkStateHandler &#123; Activity mActivity; Controller mController; // monitor platform changes private IntentFilter mNetworkStateChangedFilter; private BroadcastReceiver mNetworkStateIntentReceiver; private boolean mIsNetworkUp; public NetworkStateHandler(Activity activity, Controller controller) &#123; mActivity = activity; mController = controller; // Find out if the network is currently up. ConnectivityManager cm = (ConnectivityManager) mActivity .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = cm.getActiveNetworkInfo(); if (info != null) &#123; mIsNetworkUp = info.isAvailable(); if (Util.SUPPORT_NAVIGATION_TAB)&#123; DownloadFavicon.setNetworkUp(mIsNetworkUp); &#125; &#125; /* * enables registration for changes in network status from http stack */ mNetworkStateChangedFilter = new IntentFilter(); mNetworkStateChangedFilter.addAction( ConnectivityManager.CONNECTIVITY_ACTION); mNetworkStateIntentReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals( ConnectivityManager.CONNECTIVITY_ACTION)) &#123; NetworkInfo info = intent.getParcelableExtra( ConnectivityManager.EXTRA_NETWORK_INFO); String typeName = info.getTypeName(); String subtypeName = info.getSubtypeName(); sendNetworkType(typeName.toLowerCase(), (subtypeName != null ? subtypeName.toLowerCase() : "")); BrowserSettings.getInstance().updateConnectionType(); boolean noConnection = intent.getBooleanExtra( ConnectivityManager.EXTRA_NO_CONNECTIVITY, false); onNetworkToggle(!noConnection); &#125; &#125; &#125;; &#125; ``` 我自己则写了一个网络判断的方法 ``` java public boolean checkNetworkInfo() &#123; ConnectivityManager conMan = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE); State mobile = conMan.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState(); State wifi = conMan.getNetworkInfo(ConnectivityManager.TYPE_WIFI).getState(); if (mobile == State.CONNECTED || mobile == State.CONNECTING) return true; if (wifi == State.CONNECTED || wifi == State.CONNECTING) return true; return false; &#125;]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser打开网页为源码原因分析]]></title>
    <url>%2F2015%2F09%2F29%2FAndroid-Browser%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E4%B8%BA%E6%BA%90%E7%A0%81%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android Browser打开网页出现源码有这样的现象，使用数据流量打开网页会出现网页源码的现象，而使用WIFI打开网页则正常显示，使用WIFI后再用数据流量打开，也能正常显示。 这样的现象多半是因为数据传输时出现中断等情况，导致网页没有加载完整，所以显示异常。 还有的是因为GMS版本用的是google webview，原生的webview不支持WML页面，这个现象是正常的。现在已经极少有WML的网站。使用支持WML页面的webview则能正常显示。 Wifi上网，服务器返回html网页；gprs上网，服务器返回wml网页；这是移动门户网站的处理，网站并没有考虑到不支持wml网页的情况。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Browser打开多个窗口进行切换会闪烁]]></title>
    <url>%2F2015%2F09%2F01%2FAndroid-Browser%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2%E4%BC%9A%E9%97%AA%E7%83%81%2F</url>
    <content type="text"><![CDATA[Android Browser打开多个窗口进行切换会闪烁原因分析浏览器的多标签切换功能, 还需要一个用户交互界面, 这个界面在Android Browser中就是NavScreen了 在Android Browser中 用以和用户打交道的功能基本都被限制在了BaseUI中, 在手机上它的实现就是PhoneUI 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//点击按钮显示多窗口列表 void showNavScreen() &#123; mUiController.setBlockEvents(true); //拦截多窗口外的其他操作 if (mNavScreen == null) &#123; mNavScreen = new NavScreen(mActivity, mUiController, this); mCustomViewContainer.addView(mNavScreen, COVER_SCREEN_PARAMS); &#125; else &#123; mNavScreen.setVisibility(View.VISIBLE); mNavScreen.setAlpha(1f); mNavScreen.refreshAdapter(); &#125; mActiveTab.capture(); if (mAnimScreen == null) &#123; //这是动画的视图 ,多标签窗口切换的动画是phoneui来实现的而不是 navscreen ,也就是说我点击一个tab 剩下的看到的其实是 //真正的web窗口 mAnimScreen = new AnimScreen(mActivity); &#125; else &#123; mAnimScreen.mMain.setAlpha(1f); mAnimScreen.mTitle.setAlpha(1f); mAnimScreen.setScaleFactor(1f); &#125; //设置动画需要截图的view mAnimScreen.set(getTitleBar(), getWebView()); if (mAnimScreen.mMain.getParent() == null) &#123; //如果animscreen 的main没有父亲, 说明是执行了 全屏模式 mCustomViewContainer.addView(mAnimScreen.mMain, COVER_SCREEN_PARAMS); &#125; mCustomViewContainer.setVisibility(View.VISIBLE); mCustomViewContainer.bringToFront();//把这个view放到顶层 mAnimScreen.mMain.layout(0, 0, mContentView.getWidth(), mContentView.getHeight()); //动画的宽度和contentview一样大 int fromLeft = 0; int fromTop = getTitleBar().getHeight(); int fromRight = mContentView.getWidth(); int fromBottom = mContentView.getHeight(); int width = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_width); int height = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_height); int ntth = mActivity.getResources().getDimensionPixelSize(R.dimen.nav_tab_titleheight); int toLeft = (mContentView.getWidth() - width) / 2; int toTop = ((fromBottom - (ntth + height)) / 2 + ntth); int toRight = toLeft + width; int toBottom = toTop + height; float scaleFactor = width / (float) mContentView.getWidth(); detachTab(mActiveTab); mContentView.setVisibility(View.GONE); AnimatorSet set1 = new AnimatorSet(); AnimatorSet inanim = new AnimatorSet(); //使用上下左右的位置 使得 tab的运动轨迹 从整个屏幕 位置缩小到tab,无论当前tab在哪里 ObjectAnimator tx = ObjectAnimator.ofInt(mAnimScreen.mContent, "left", fromLeft, toLeft); ObjectAnimator ty = ObjectAnimator.ofInt(mAnimScreen.mContent, "top", fromTop, toTop); ObjectAnimator tr = ObjectAnimator.ofInt(mAnimScreen.mContent, "right", fromRight, toRight); ObjectAnimator tb = ObjectAnimator.ofInt(mAnimScreen.mContent, "bottom", fromBottom, toBottom); ObjectAnimator title = ObjectAnimator.ofFloat(mAnimScreen.mTitle, "alpha", 1f, 0f); ObjectAnimator sx = ObjectAnimator.ofFloat(mAnimScreen, "scaleFactor", 1f, scaleFactor); //这个动画是透明动画 ObjectAnimator blend1 = ObjectAnimator.ofFloat(mAnimScreen.mMain, "alpha", 1f, 0f); blend1.setDuration(100); inanim.playTogether(tx, ty, tr, tb, sx, title); inanim.setDuration(200); set1.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator anim) &#123; mCustomViewContainer.removeView(mAnimScreen.mMain); finishAnimationIn(); mUiController.setBlockEvents(false); &#125; &#125;); set1.playSequentially(inanim, blend1);//inanim播放ok后播放 blend1 也就是先缩放然后在透明 set1.start(); &#125; 看了代码，发现动画有个透明效果的动画。研究之后才发现，其实浏览器切换并不是“闪烁”，而是一个透明动画，这个动画造成了“闪烁”的现象，把这个动画去掉后，可以发现闪烁的现象没有了，而且切换窗口的时候更加平滑。]]></content>
      <categories>
        <category>Android Browser</category>
      </categories>
      <tags>
        <tag>Android Browser</tag>
      </tags>
  </entry>
</search>
